#!/usr/bin/env node

// src/index.ts
import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ErrorCode,
  ListToolsRequestSchema,
  McpError
} from "@modelcontextprotocol/sdk/types.js";
import { z } from "zod";
import { Command } from "commander";
import dotenv from "dotenv";
import chalk from "chalk";
import path2 from "path";
import fs2 from "fs/promises";

// src/version.ts
import { readFileSync } from "fs";
import { fileURLToPath } from "url";
import { dirname, join } from "path";
var __filename = fileURLToPath(import.meta.url);
var __dirname = dirname(__filename);
function getVersion() {
  try {
    const packageJsonPath = join(__dirname, "..", "package.json");
    const packageJson = JSON.parse(readFileSync(packageJsonPath, "utf8"));
    return packageJson.version;
  } catch (error) {
    console.error("Error reading version from package.json:", error);
    return "0.0.0";
  }
}
var VERSION = getVersion();

// src/services/figma-api.ts
import axios from "axios";
import NodeCache from "node-cache";
import pRetry from "p-retry";
import pLimit from "p-limit";
import fs from "fs/promises";
import * as fsSync from "fs";
import path from "path";
import os from "os";
var FigmaApiError = class extends Error {
  constructor(message, status, code, details) {
    super(message);
    this.status = status;
    this.code = code;
    this.details = details;
    this.name = "FigmaApiError";
  }
};
var FigmaApiService = class _FigmaApiService {
  client;
  cache;
  rateLimiter;
  config;
  constructor(config) {
    this.config = {
      baseUrl: "https://api.figma.com/v1",
      timeout: 3e4,
      retryAttempts: 3,
      retryDelay: 1e3,
      cacheConfig: {
        ttl: 300,
        // 5 minutes
        maxSize: 1e3
      },
      rateLimitConfig: {
        requestsPerMinute: 60,
        burstSize: 10
      },
      ...config
    };
    this.client = axios.create({
      baseURL: this.config.baseUrl,
      timeout: this.config.timeout,
      headers: {
        "X-Figma-Token": this.config.apiKey,
        "Content-Type": "application/json",
        "User-Agent": "Custom-Figma-MCP-Server/1.0.0"
      }
    });
    this.cache = new NodeCache({
      stdTTL: this.config.cacheConfig.ttl,
      maxKeys: this.config.cacheConfig.maxSize,
      useClones: false
    });
    this.rateLimiter = pLimit(this.config.rateLimitConfig.burstSize);
    this.setupInterceptors();
  }
  setupInterceptors() {
    this.client.interceptors.request.use(
      (config) => {
        console.error(`[Figma API] ${config.method?.toUpperCase()} ${config.url}`);
        return config;
      },
      (error) => {
        console.error("[Figma API] Request error:", error);
        return Promise.reject(error);
      }
    );
    this.client.interceptors.response.use(
      (response) => {
        console.error(`[Figma API] Response ${response.status} for ${response.config.url}`);
        return response;
      },
      (error) => {
        if (error.response) {
          const { status, data } = error.response;
          const figmaError = data;
          throw new FigmaApiError(
            figmaError.err || `HTTP ${status} error`,
            status,
            figmaError.err,
            data
          );
        } else if (error.request) {
          throw new FigmaApiError(
            "Network error: No response received",
            0,
            "NETWORK_ERROR",
            error.request
          );
        } else {
          throw new FigmaApiError(
            `Request setup error: ${error.message}`,
            0,
            "REQUEST_ERROR",
            error
          );
        }
      }
    );
  }
  async makeRequest(endpoint, options = {}, useCache = true) {
    const cacheKey = `${endpoint}:${JSON.stringify(options)}`;
    if (useCache) {
      const cached = this.cache.get(cacheKey);
      if (cached) {
        console.error(`[Figma API] Cache hit for ${endpoint}`);
        return cached;
      }
    }
    return this.rateLimiter(async () => {
      const response = await pRetry(
        async () => {
          const response2 = await this.client.get(endpoint, {
            params: this.buildParams(options)
          });
          return response2;
        },
        {
          retries: this.config.retryAttempts,
          minTimeout: this.config.retryDelay,
          factor: 2,
          onFailedAttempt: (error) => {
            console.warn(
              `[Figma API] Attempt ${error.attemptNumber} failed for ${endpoint}. ${error.retriesLeft} retries left.`
            );
          }
        }
      );
      const data = response.data;
      if (useCache) {
        this.cache.set(cacheKey, data);
      }
      return data;
    });
  }
  buildParams(options) {
    const params = {};
    if (options.version) params.version = options.version;
    if (options.ids) params.ids = options.ids.join(",");
    if (options.depth !== void 0) params.depth = options.depth.toString();
    if (options.geometry) params.geometry = options.geometry;
    if (options.plugin_data) params.plugin_data = options.plugin_data;
    if (options.branch_data) params.branch_data = "true";
    if (options.use_absolute_bounds) params.use_absolute_bounds = "true";
    return params;
  }
  /**
   * Get a Figma file by its key
   */
  async getFile(fileKey, options = {}) {
    if (!fileKey || typeof fileKey !== "string") {
      throw new FigmaApiError("File key is required and must be a string");
    }
    try {
      return await this.makeRequest(`/files/${fileKey}`, options);
    } catch (error) {
      if (error instanceof FigmaApiError) {
        throw error;
      }
      throw new FigmaApiError(`Failed to get file ${fileKey}: ${error}`);
    }
  }
  /**
   * Get specific nodes from a Figma file
   */
  async getFileNodes(fileKey, nodeIds, options = {}) {
    if (!fileKey || typeof fileKey !== "string") {
      throw new FigmaApiError("File key is required and must be a string");
    }
    if (!nodeIds || !Array.isArray(nodeIds) || nodeIds.length === 0) {
      throw new FigmaApiError("Node IDs are required and must be a non-empty array");
    }
    try {
      return await this.makeRequest(
        `/files/${fileKey}/nodes`,
        { ...options, ids: nodeIds }
      );
    } catch (error) {
      if (error instanceof FigmaApiError) {
        throw error;
      }
      throw new FigmaApiError(`Failed to get nodes from file ${fileKey}: ${error}`);
    }
  }
  /**
   * Get images for specific nodes
   */
  async getImages(fileKey, nodeIds, options = {}) {
    if (!fileKey || typeof fileKey !== "string") {
      throw new FigmaApiError("File key is required and must be a string");
    }
    if (!nodeIds || !Array.isArray(nodeIds) || nodeIds.length === 0) {
      throw new FigmaApiError("Node IDs are required and must be a non-empty array");
    }
    try {
      const params = {
        ids: nodeIds.join(","),
        format: options.format || "png"
      };
      if (options.scale) params.scale = options.scale.toString();
      if (options.svg_include_id) params.svg_include_id = "true";
      if (options.svg_simplify_stroke) params.svg_simplify_stroke = "true";
      if (options.use_absolute_bounds) params.use_absolute_bounds = "true";
      if (options.version) params.version = options.version;
      const response = await this.client.get(
        `/images/${fileKey}`,
        { params }
      );
      return response.data;
    } catch (error) {
      if (error instanceof FigmaApiError) {
        throw error;
      }
      throw new FigmaApiError(`Failed to get images from file ${fileKey}: ${error}`);
    }
  }
  /**
   * Get cache statistics
   */
  getCacheStats() {
    const stats = this.cache.getStats();
    return {
      keys: stats.keys,
      hits: stats.hits,
      misses: stats.misses,
      size: stats.ksize + stats.vsize
    };
  }
  /**
   * Clear cache
   */
  clearCache() {
    this.cache.flushAll();
    console.error("[Figma API] Cache cleared");
  }
  /**
   * Update API key
   */
  updateApiKey(apiKey) {
    if (!apiKey || typeof apiKey !== "string") {
      throw new FigmaApiError("API key is required and must be a string");
    }
    this.config.apiKey = apiKey;
    this.client.defaults.headers["X-Figma-Token"] = apiKey;
    console.error("[Figma API] API key updated");
  }
  /**
   * Robust IDE-aware path resolution for universal compatibility
   */
  static resolvePath(inputPath) {
    const normalizedPath = inputPath.trim().replace(/[^\x20-\x7E]/g, "");
    console.error(`[Figma API] Input path: "${inputPath}" -> normalized: "${normalizedPath}"`);
    if (path.isAbsolute(normalizedPath) && !this.isSystemRoot(normalizedPath) && normalizedPath.length > 1) {
      if (!this.isDangerousPath(normalizedPath)) {
        console.error(`[Figma API] Using safe absolute path: ${normalizedPath}`);
        return normalizedPath;
      } else {
        console.error(`[Figma API] \u26A0\uFE0F Absolute path is dangerous, switching to relative: ${normalizedPath}`);
      }
    }
    const workspaceInfo = this.getActualWorkspaceDirectory();
    console.error(`[Figma API] Using workspace directory: ${workspaceInfo.workspaceDir} (${workspaceInfo.confidence} confidence from ${workspaceInfo.source})`);
    if (this.isDangerousPath(workspaceInfo.workspaceDir) || this.isSystemRoot(workspaceInfo.workspaceDir)) {
      console.error(`[Figma API] \u{1F6A8} CRITICAL: Workspace directory is dangerous/root: ${workspaceInfo.workspaceDir}`);
      const userHome = os.homedir();
      const safeFallbackWorkspace = path.join(userHome, "figma-mcp-workspace");
      console.error(`[Figma API] \u{1F6E1}\uFE0F Using bulletproof safe workspace: ${safeFallbackWorkspace}`);
      workspaceInfo.workspaceDir = safeFallbackWorkspace;
      workspaceInfo.confidence = "low";
      workspaceInfo.source = "Emergency Safe Fallback";
    }
    let cleanPath = normalizedPath;
    if (cleanPath.startsWith("./")) {
      cleanPath = cleanPath.substring(2);
    } else if (cleanPath.startsWith("../")) {
      cleanPath = cleanPath;
    } else if (cleanPath.startsWith("/")) {
      cleanPath = cleanPath.substring(1);
    }
    if (!cleanPath || cleanPath === "." || cleanPath === "") {
      cleanPath = "figma-assets";
    }
    const resolvedPath = path.resolve(workspaceInfo.workspaceDir, cleanPath);
    if (this.isDangerousPath(resolvedPath) || this.isSystemRoot(path.dirname(resolvedPath))) {
      console.error(`[Figma API] \u{1F6A8} EMERGENCY BLOCK: Resolved path is still dangerous: ${resolvedPath}`);
      console.error(`[Figma API] \u{1F6A8} This indicates a severe Cursor IDE workspace detection failure`);
      const userHome = os.homedir();
      const emergencyPath = path.resolve(userHome, "figma-emergency-downloads", cleanPath);
      console.error(`[Figma API] \u{1F6E1}\uFE0F Using emergency safe path: ${emergencyPath}`);
      if (this.isDangerousPath(emergencyPath)) {
        console.error(`[Figma API] \u{1F4A5} CRITICAL SYSTEM ERROR: Even emergency path is dangerous!`);
        throw new FigmaApiError(`System error: Cannot create safe download path. Emergency path ${emergencyPath} is dangerous. Please check your system configuration.`);
      }
      return emergencyPath;
    }
    console.error(`[Figma API] \u2705 Path resolution: "${normalizedPath}" -> "${resolvedPath}"`);
    console.error(`[Figma API] Environment: workspace="${workspaceInfo.workspaceDir}", PWD="${process.env.PWD}", resolved="${resolvedPath}"`);
    return resolvedPath;
  }
  /**
   * Enhanced project directory detection by looking for common project markers
   * Specifically optimized for Cursor IDE environment
   */
  static findProjectDirectoryByMarkers() {
    const candidates = [];
    const projectMarkers = [
      { file: "package.json", score: 10 },
      { file: ".git", score: 8 },
      { file: "tsconfig.json", score: 7 },
      { file: "yarn.lock", score: 6 },
      { file: "package-lock.json", score: 6 },
      { file: "pnpm-lock.yaml", score: 6 },
      { file: "node_modules", score: 5 },
      { file: "src", score: 4 },
      { file: "dist", score: 3 },
      { file: "README.md", score: 2 },
      { file: ".gitignore", score: 3 },
      { file: "index.js", score: 2 },
      { file: "index.ts", score: 2 }
    ];
    const startingPoints = [];
    if (process.env.PWD && !this.isSystemRoot(process.env.PWD)) {
      startingPoints.push(process.env.PWD);
    }
    if (process.env.INIT_CWD && !this.isSystemRoot(process.env.INIT_CWD)) {
      startingPoints.push(process.env.INIT_CWD);
    }
    if (!this.isSystemRoot(process.cwd())) {
      startingPoints.push(process.cwd());
    }
    const userDirs = [
      path.join(os.homedir(), "Desktop"),
      path.join(os.homedir(), "Documents"),
      path.join(os.homedir(), "Projects"),
      path.join(os.homedir(), "Development"),
      path.join(os.homedir(), "Code"),
      os.homedir()
    ];
    startingPoints.push(...userDirs);
    const uniqueStartingPoints = [...new Set(startingPoints)];
    console.error(`[Figma API] \u{1F50D} Project marker search starting from ${uniqueStartingPoints.length} locations`);
    for (const startDir of uniqueStartingPoints) {
      try {
        console.error(`[Figma API] \u{1F50D} Searching from: ${startDir}`);
        let currentDir = startDir;
        const maxLevels = 8;
        for (let level = 0; level < maxLevels; level++) {
          let totalScore = 0;
          for (const marker of projectMarkers) {
            const markerPath = path.join(currentDir, marker.file);
            try {
              fsSync.accessSync(markerPath);
              totalScore += marker.score;
              if (marker.file === "package.json") {
                try {
                  const packageContent = fsSync.readFileSync(markerPath, "utf8");
                  const packageJson = JSON.parse(packageContent);
                  if (packageJson.name && !packageJson.name.startsWith("figma-mcp-workspace")) {
                    totalScore += 5;
                  }
                } catch {
                }
              }
            } catch {
            }
          }
          if (totalScore >= 10 && !candidates.includes(currentDir)) {
            candidates.push(currentDir);
            console.error(`[Figma API] \u2705 Project found with score ${totalScore}: ${currentDir}`);
          }
          const parentDir = path.dirname(currentDir);
          if (parentDir === currentDir) break;
          currentDir = parentDir;
        }
        if (startDir !== os.homedir()) {
          try {
            const entries = fsSync.readdirSync(startDir, { withFileTypes: true });
            for (const entry of entries.slice(0, 20)) {
              if (entry.isDirectory() && !entry.name.startsWith(".") && entry.name !== "node_modules") {
                const subDir = path.join(startDir, entry.name);
                let totalScore = 0;
                for (const marker of projectMarkers) {
                  const markerPath = path.join(subDir, marker.file);
                  try {
                    fsSync.accessSync(markerPath);
                    totalScore += marker.score;
                  } catch {
                  }
                }
                if (totalScore >= 10 && !candidates.includes(subDir)) {
                  candidates.push(subDir);
                  console.error(`[Figma API] \u2705 Project found (subdirectory) with score ${totalScore}: ${subDir}`);
                }
              }
            }
          } catch {
          }
        }
      } catch (error) {
        console.error(`[Figma API] \u26A0\uFE0F Error searching from ${startDir}:`, error);
      }
    }
    console.error(`[Figma API] \u{1F4CA} Project marker search found ${candidates.length} candidates`);
    return candidates;
  }
  /**
   * Check if a directory looks like a valid project directory
   */
  static isValidProjectDirectory(dir) {
    const projectIndicators = [
      "package.json",
      "tsconfig.json",
      ".git",
      "src",
      "node_modules"
    ];
    let indicatorCount = 0;
    for (const indicator of projectIndicators) {
      try {
        fsSync.accessSync(path.join(dir, indicator));
        indicatorCount++;
      } catch {
      }
    }
    return indicatorCount >= 2;
  }
  /**
   * Create directory with enhanced verification and universal IDE compatibility
   */
  static async createDirectorySafely(resolvedPath, originalPath) {
    if (!resolvedPath || resolvedPath.length === 0) {
      throw new Error("Invalid or empty path after resolution");
    }
    if (this.isDangerousPath(resolvedPath)) {
      console.error(`[Figma API] SAFETY BLOCK: Refusing to create directory at dangerous location: ${resolvedPath}`);
      throw new FigmaApiError(`Blocked dangerous directory creation at: ${resolvedPath}. Original path: ${originalPath}`);
    }
    console.error(`[Figma API] Creating directory: "${originalPath}" -> "${resolvedPath}"`);
    try {
      await fs.mkdir(resolvedPath, { recursive: true, mode: 493 });
      const stats = await fs.stat(resolvedPath);
      if (!stats.isDirectory()) {
        throw new Error("Path exists but is not a directory");
      }
      const testFile = path.join(resolvedPath, ".figma-test-write");
      try {
        await fs.writeFile(testFile, "test");
        await fs.unlink(testFile);
      } catch (writeError) {
        throw new Error(`Directory exists but is not writable: ${writeError instanceof Error ? writeError.message : String(writeError)}`);
      }
      console.error(`[Figma API] \u2705 Directory verified: ${resolvedPath}`);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`[Figma API] \u274C Directory creation failed:`, {
        originalPath,
        resolvedPath,
        cwd: process.cwd(),
        environment: {
          PWD: process.env.PWD,
          INIT_CWD: process.env.INIT_CWD,
          PROJECT_ROOT: process.env.PROJECT_ROOT,
          WORKSPACE_ROOT: process.env.WORKSPACE_ROOT
        },
        error: errorMessage
      });
      throw new FigmaApiError(`Failed to create/verify directory: ${errorMessage}`);
    }
  }
  /**
   * Verify that assets exist in the expected location (universal IDE compatibility)
   */
  static async verifyAssetsLocation(expectedPaths) {
    const verified = [];
    for (const expectedPath of expectedPaths) {
      try {
        const stat = await fs.stat(expectedPath);
        const relativePath = path.relative(process.cwd(), expectedPath);
        verified.push({
          path: expectedPath,
          exists: true,
          size: stat.size,
          relativePath: relativePath.startsWith("..") ? expectedPath : relativePath
        });
      } catch (error) {
        verified.push({
          path: expectedPath,
          exists: false
        });
      }
    }
    const summary = {
      total: verified.length,
      found: verified.filter((v) => v.exists).length,
      missing: verified.filter((v) => !v.exists).length
    };
    return { verified, summary };
  }
  /**
   * Advanced asset recovery system for IDE compatibility issues
   * Searches common alternative download locations and recovers assets to project folder
   */
  static async findAndRecoverMissingAssets(expectedResults, targetDirectory) {
    const recovered = [];
    const missingAssets = expectedResults.filter((r) => r.success);
    console.error(`[Figma API] \u{1F50D} Searching for ${missingAssets.length} potentially misplaced assets...`);
    const searchLocations = this.getAssetSearchLocations();
    const uniqueSearchLocations = [...new Set(searchLocations)].filter((loc) => loc !== targetDirectory);
    const recursiveSearchDirs = [
      path.join(os.homedir(), "figma-workspace"),
      os.homedir()
    ];
    for (const asset of missingAssets) {
      const expectedPath = asset.filePath;
      const filename = path.basename(expectedPath);
      try {
        await fs.access(expectedPath);
        continue;
      } catch {
      }
      console.error(`[Figma API] \u{1F50D} Searching for missing file: ${filename}`);
      let foundPath = null;
      for (const searchLoc of uniqueSearchLocations) {
        try {
          const candidatePath = path.join(searchLoc, filename);
          await fs.access(candidatePath);
          const stat = await fs.stat(candidatePath);
          if (stat.size > 0) {
            foundPath = candidatePath;
            console.error(`[Figma API] \u2705 Found ${filename} at: ${candidatePath} (${(stat.size / 1024).toFixed(1)}KB)`);
            break;
          }
        } catch {
        }
      }
      if (!foundPath) {
        foundPath = await this.searchFileRecursively(filename, recursiveSearchDirs);
      }
      if (foundPath) {
        try {
          await _FigmaApiService.createDirectorySafely(targetDirectory, targetDirectory);
          await fs.rename(foundPath, expectedPath);
          recovered.push({
            nodeId: asset.nodeId,
            nodeName: asset.nodeName,
            oldPath: foundPath,
            newPath: expectedPath,
            success: true
          });
          console.error(`[Figma API] \u2705 Recovered ${filename}: ${foundPath} \u2192 ${expectedPath}`);
        } catch (moveError) {
          try {
            await fs.copyFile(foundPath, expectedPath);
            await fs.unlink(foundPath);
            recovered.push({
              nodeId: asset.nodeId,
              nodeName: asset.nodeName,
              oldPath: foundPath,
              newPath: expectedPath,
              success: true
            });
            console.error(`[Figma API] \u2705 Recovered ${filename} via copy: ${foundPath} \u2192 ${expectedPath}`);
          } catch (copyError) {
            recovered.push({
              nodeId: asset.nodeId,
              nodeName: asset.nodeName,
              oldPath: foundPath,
              newPath: expectedPath,
              success: false
            });
            console.error(`[Figma API] \u274C Failed to recover ${filename}:`, copyError);
          }
        }
      } else {
        console.error(`[Figma API] \u274C Could not locate missing file: ${filename}`);
      }
    }
    const summary = {
      total: missingAssets.length,
      found: recovered.length,
      recovered: recovered.filter((r) => r.success).length,
      failed: recovered.filter((r) => !r.success).length
    };
    if (summary.recovered > 0) {
      console.error(`[Figma API] \u{1F389} Recovery completed: ${summary.recovered}/${summary.total} assets recovered to project folder`);
    } else if (summary.total > 0) {
      console.error(`[Figma API] \u26A0\uFE0F  No assets recovered - files may have been downloaded to an unknown location`);
    }
    return { recovered, summary };
  }
  /**
   * Search for a file recursively in given directories (limited depth)
   */
  static async searchFileRecursively(filename, searchDirs, maxDepth = 3) {
    for (const searchDir of searchDirs) {
      try {
        const found = await this.searchInDirectory(searchDir, filename, maxDepth);
        if (found) {
          return found;
        }
      } catch (error) {
        console.error(`[Figma API] Error searching in ${searchDir}:`, error);
      }
    }
    return null;
  }
  /**
   * Search for a file in a specific directory with depth limit
   */
  static async searchInDirectory(dir, filename, maxDepth, currentDepth = 0) {
    if (currentDepth >= maxDepth) {
      return null;
    }
    try {
      const entries = await fs.readdir(dir, { withFileTypes: true });
      for (const entry of entries) {
        if (entry.isFile() && entry.name === filename) {
          const filePath = path.join(dir, entry.name);
          const stat = await fs.stat(filePath);
          if (stat.size > 0) {
            return filePath;
          }
        }
      }
      for (const entry of entries) {
        if (entry.isDirectory() && !entry.name.startsWith(".") && entry.name !== "node_modules") {
          const subDir = path.join(dir, entry.name);
          const found = await this.searchInDirectory(subDir, filename, maxDepth, currentDepth + 1);
          if (found) {
            return found;
          }
        }
      }
    } catch (error) {
    }
    return null;
  }
  /**
   * Download images for specific nodes directly (without requiring export settings)
   */
  async downloadImages(fileKey, nodeIds, localPath, options = {}) {
    const resolvedPath = _FigmaApiService.resolvePath(localPath);
    await _FigmaApiService.createDirectorySafely(resolvedPath, localPath);
    const results = [];
    const usedFilenames = /* @__PURE__ */ new Set();
    const filenameCounters = /* @__PURE__ */ new Map();
    const contentHashes = /* @__PURE__ */ new Map();
    try {
      const existingFiles = await fs.readdir(resolvedPath);
      existingFiles.forEach((file) => {
        usedFilenames.add(file);
        console.error(`[Figma API] \u{1F4C1} Existing file detected: ${file}`);
      });
    } catch (error) {
      console.error(`[Figma API] \u{1F4C1} Target directory empty or doesn't exist yet`);
    }
    const generateContentHash = (node, format, scale) => {
      const hashComponents = [
        node.type,
        format,
        scale.toString(),
        JSON.stringify(node.fills || []),
        JSON.stringify(node.strokes || []),
        JSON.stringify(node.effects || []),
        node.cornerRadius || 0,
        node.strokeWeight || 0,
        node.type === "TEXT" ? node.characters || "" : "",
        node.absoluteBoundingBox ? `${Math.round(node.absoluteBoundingBox.width)}x${Math.round(node.absoluteBoundingBox.height)}` : ""
      ];
      return hashComponents.join("|").replace(/[^a-zA-Z0-9]/g, "").substring(0, 16);
    };
    const isReusableAsset = (node, sanitizedName) => {
      const name = sanitizedName.toLowerCase();
      const iconPatterns = [
        "akar-icons-",
        "dashicons-",
        "ci-",
        "uis-",
        "mdi-",
        "ant-design-",
        "feather-",
        "heroicons-",
        "lucide-",
        "tabler-",
        "phosphor-",
        "icon-",
        "ico-"
      ];
      const isIcon = iconPatterns.some((pattern) => name.includes(pattern));
      const size = node.absoluteBoundingBox;
      const isSmallSize = size ? size.width <= 100 && size.height <= 100 : false;
      const isVectorType = node.type === "VECTOR" || node.type === "BOOLEAN_OPERATION" || node.type === "COMPONENT";
      const shouldDeduplicate = isIcon || isSmallSize && isVectorType;
      if (shouldDeduplicate) {
        console.error(`[Figma API] \u{1F517} Detected reusable asset: "${name}" (icon: ${isIcon}, small: ${isSmallSize}, vector: ${isVectorType})`);
      }
      return shouldDeduplicate;
    };
    const generateUniqueFilename = (node, baseName, extension, format, scale) => {
      const baseNameWithScale = scale === 1 ? `${baseName}-x1` : `${baseName}-x${scale}`;
      const baseFilename = `${baseNameWithScale}.${extension}`;
      if (isReusableAsset(node, baseName)) {
        const contentHash = generateContentHash(node, format, scale);
        if (contentHashes.has(contentHash)) {
          const existingAsset = contentHashes.get(contentHash);
          console.error(`[Figma API] \u{1F517} Content duplicate detected: "${baseName}" \u2192 reusing "${existingAsset.filename}" (same as ${existingAsset.nodeName})`);
          return existingAsset.filename;
        }
        contentHashes.set(contentHash, { filename: baseFilename, nodeId: node.id, nodeName: baseName });
      }
      if (!usedFilenames.has(baseFilename)) {
        usedFilenames.add(baseFilename);
        return baseFilename;
      }
      const counter = filenameCounters.get(baseNameWithScale) || 1;
      let uniqueFilename;
      let currentCounter = counter + 1;
      do {
        uniqueFilename = `${baseNameWithScale}-${currentCounter}.${extension}`;
        currentCounter++;
      } while (usedFilenames.has(uniqueFilename));
      filenameCounters.set(baseNameWithScale, currentCounter - 1);
      usedFilenames.add(uniqueFilename);
      console.error(`[Figma API] \u{1F504} Filename duplicate resolved: "${baseFilename}" \u2192 "${uniqueFilename}"`);
      return uniqueFilename;
    };
    try {
      const nodeResponse = await this.getFileNodes(fileKey, nodeIds, {
        depth: 1,
        use_absolute_bounds: true
      });
      const format = (options.format || "png").toLowerCase();
      let scale = options.scale || 1;
      if (format === "svg") {
        scale = 1;
      }
      const imageResponse = await this.getImages(fileKey, nodeIds, {
        format,
        scale,
        use_absolute_bounds: true
      });
      for (const nodeId of nodeIds) {
        const nodeWrapper = nodeResponse.nodes[nodeId];
        const imageUrl = imageResponse.images[nodeId];
        if (!nodeWrapper) {
          results.push({
            nodeId,
            nodeName: "Unknown",
            filePath: "",
            success: false,
            error: `Node ${nodeId} not found`
          });
          continue;
        }
        if (!imageUrl) {
          results.push({
            nodeId,
            nodeName: nodeWrapper.document?.name || "Unknown",
            filePath: "",
            success: false,
            error: "No image URL returned from Figma API"
          });
          continue;
        }
        const nodeName = nodeWrapper.document?.name || `node-${nodeId}`;
        const sanitizedNodeName = nodeName.replace(/[/\\:*?"<>|]/g, "-").replace(/\s+/g, " ").trim();
        const extension = format;
        const filename = generateUniqueFilename(nodeWrapper.document, sanitizedNodeName, extension, format, scale);
        const filePath = path.join(resolvedPath, filename);
        console.error(`[Figma API] Debug - Node ID: ${nodeId}, Node Name: "${nodeName}", Filename: "${filename}"`);
        try {
          const downloadResponse = await axios.get(imageUrl, {
            responseType: "arraybuffer",
            timeout: 3e4,
            headers: {
              "User-Agent": "Custom-Figma-MCP-Server/1.0.0"
            }
          });
          await fs.writeFile(filePath, Buffer.from(downloadResponse.data));
          results.push({
            nodeId,
            nodeName: sanitizedNodeName,
            filePath,
            success: true
          });
          console.error(`[Figma API] Downloaded: ${filename} (${(downloadResponse.data.byteLength / 1024).toFixed(1)}KB)`);
        } catch (downloadError) {
          results.push({
            nodeId,
            nodeName: sanitizedNodeName,
            filePath,
            success: false,
            error: `Download failed: ${downloadError instanceof Error ? downloadError.message : String(downloadError)}`
          });
          console.error(`[Figma API] Failed to download ${filename}:`, downloadError);
        }
      }
    } catch (error) {
      for (const nodeId of nodeIds) {
        results.push({
          nodeId,
          nodeName: "Unknown",
          filePath: "",
          success: false,
          error: `Failed to fetch node data: ${error instanceof Error ? error.message : String(error)}`
        });
      }
    }
    const summary = {
      total: results.length,
      successful: results.filter((r) => r.success).length,
      failed: results.filter((r) => !r.success).length
    };
    console.error(`[Figma API] Download completed: ${summary.successful}/${summary.total} successful`);
    let workspaceEnforcement = null;
    if (summary.successful > 0 && !options.skipWorkspaceEnforcement) {
      try {
        workspaceEnforcement = await _FigmaApiService.enforceWorkspaceLocation(results, localPath);
        console.error(`[Figma API] \u{1F3AF} Workspace enforcement: ${workspaceEnforcement.summary.moved} moved, ${workspaceEnforcement.summary.alreadyCorrect} already correct`);
      } catch (enforcementError) {
        console.error(`[Figma API] \u26A0\uFE0F Workspace enforcement failed, falling back to recovery:`, enforcementError);
        const expectedPaths = results.filter((r) => r.success).map((r) => r.filePath);
        if (expectedPaths.length > 0) {
          const verification = await _FigmaApiService.verifyAssetsLocation(expectedPaths);
          if (verification.summary.missing > 0) {
            console.error(`[Figma API] \u26A0\uFE0F ${verification.summary.missing} assets missing from expected location, attempting recovery...`);
            const recovery = await _FigmaApiService.findAndRecoverMissingAssets(results, resolvedPath);
            if (recovery.summary.recovered > 0) {
              console.error(`[Figma API] \u{1F389} Successfully recovered ${recovery.summary.recovered} assets to project directory!`);
              for (const recoveredAsset of recovery.recovered) {
                const resultIndex = results.findIndex((r) => r.nodeId === recoveredAsset.nodeId);
                if (resultIndex !== -1 && recoveredAsset.success && results[resultIndex]) {
                  results[resultIndex].filePath = recoveredAsset.newPath;
                  results[resultIndex].success = true;
                }
              }
            }
          }
        }
      }
    }
    return {
      downloaded: results,
      summary,
      workspaceEnforcement: workspaceEnforcement ? {
        finalLocation: workspaceEnforcement.finalLocation,
        moved: workspaceEnforcement.summary.moved,
        workspaceSource: workspaceEnforcement.workspaceInfo.source,
        confidence: workspaceEnforcement.workspaceInfo.confidence
      } : null
    };
  }
  /**
   * Download images to local directory based on export settings
   */
  async downloadImagesWithExportSettings(fileKey, nodes, localPath, options = {}) {
    const resolvedPath = _FigmaApiService.resolvePath(localPath);
    await _FigmaApiService.createDirectorySafely(resolvedPath, localPath);
    const results = [];
    const usedFilenames = /* @__PURE__ */ new Set();
    const filenameCounters = /* @__PURE__ */ new Map();
    const contentHashes = /* @__PURE__ */ new Map();
    const existingFiles = /* @__PURE__ */ new Set();
    try {
      const files = await fs.readdir(resolvedPath);
      files.forEach((file) => existingFiles.add(file));
      if (options.overwriteExisting) {
        console.error(`[Figma API] \u{1F504} Overwrite mode: Will replace ${files.length} existing files if needed`);
      } else {
        files.forEach((file) => {
          usedFilenames.add(file);
          console.error(`[Figma API] \u{1F4C1} Existing file detected: ${file} (will increment if duplicate)`);
        });
      }
    } catch (error) {
      console.error(`[Figma API] \u{1F4C1} Target directory empty or doesn't exist yet`);
    }
    const generateContentHash = (node, exportSetting) => {
      const hashComponents = [
        node.type,
        // Don't include node.id for icons - we want to deduplicate identical icons regardless of their node ID
        // node.id, // REMOVED - this was preventing icon deduplication
        node.name,
        // Keep node name for uniqueness
        exportSetting.format,
        exportSetting.constraint?.type || "none",
        exportSetting.constraint?.value || 1,
        exportSetting.suffix || "",
        JSON.stringify(node.fills || []),
        JSON.stringify(node.strokes || []),
        JSON.stringify(node.effects || []),
        node.cornerRadius || 0,
        node.strokeWeight || 0,
        node.type === "TEXT" ? node.characters || "" : "",
        node.absoluteBoundingBox ? `${Math.round(node.absoluteBoundingBox.width)}x${Math.round(node.absoluteBoundingBox.height)}` : "",
        // Add more specific properties for better differentiation
        node.blendMode || "",
        node.opacity || 1,
        JSON.stringify(node.strokeDashes || [])
      ];
      const hashString = hashComponents.join("|");
      return hashString.replace(/[^a-zA-Z0-9]/g, "").substring(0, 32);
    };
    const isReusableAsset = (node, sanitizedName) => {
      const name = sanitizedName.toLowerCase();
      const iconPatterns = [
        "akar-icons-",
        "dashicons-",
        "ci-",
        "uis-",
        "mdi-",
        "ant-design-",
        "feather-",
        "heroicons-",
        "lucide-",
        "tabler-",
        "phosphor-",
        "icon-",
        "ico-"
      ];
      const isIcon = iconPatterns.some((pattern) => name.includes(pattern));
      const size = node.absoluteBoundingBox;
      const isSmallSize = size ? size.width <= 100 && size.height <= 100 : false;
      const isVectorType = node.type === "VECTOR" || node.type === "BOOLEAN_OPERATION" || node.type === "COMPONENT";
      const shouldDeduplicate = isIcon || isSmallSize && isVectorType;
      if (shouldDeduplicate) {
        console.error(`[Figma API] \u{1F517} Detected reusable asset: "${name}" (icon: ${isIcon}, small: ${isSmallSize}, vector: ${isVectorType})`);
      }
      return shouldDeduplicate;
    };
    const generateUniqueFilename = (node, baseName, extension, exportSetting) => {
      const baseFilename = `${baseName}.${extension}`;
      if (isReusableAsset(node, baseName)) {
        const contentHash = generateContentHash(node, exportSetting);
        if (contentHashes.has(contentHash)) {
          const existingAsset = contentHashes.get(contentHash);
          console.error(`[Figma API] \u{1F517} Content duplicate detected: "${baseName}" \u2192 reusing "${existingAsset.filename}" (same as ${existingAsset.nodeName})`);
          return existingAsset.filename;
        }
        contentHashes.set(contentHash, { filename: baseFilename, nodeId: node.id, nodeName: baseName });
        console.error(`[Figma API] \u{1F195} New unique icon registered: "${baseName}" with hash ${contentHash.substring(0, 8)}...`);
      }
      if (!usedFilenames.has(baseFilename)) {
        usedFilenames.add(baseFilename);
        return baseFilename;
      }
      const counter = filenameCounters.get(baseName) || 0;
      let uniqueFilename;
      let currentCounter = counter + 1;
      do {
        uniqueFilename = `${baseName}-${currentCounter}.${extension}`;
        currentCounter++;
      } while (usedFilenames.has(uniqueFilename));
      filenameCounters.set(baseName, currentCounter - 1);
      usedFilenames.add(uniqueFilename);
      console.error(`[Figma API] \u{1F504} Filename duplicate resolved: "${baseFilename}" \u2192 "${uniqueFilename}"`);
      return uniqueFilename;
    };
    const nodesToExport = [];
    const findExportableNodes = (node) => {
      const nodeName = node.name.toLowerCase();
      const isIconName = ["uis:", "dashicons:", "ci:", "icon", "svg"].some((keyword) => nodeName.includes(keyword));
      if (isIconName) {
        console.error(`[Figma API] \u{1F50D} DEBUG: Found potential icon "${node.name}" (${node.type})`);
        console.error(`[Figma API]   \u{1F4CB} Export settings: ${node.exportSettings ? node.exportSettings.length : 0} found`);
        if (node.exportSettings && node.exportSettings.length > 0) {
          node.exportSettings.forEach((setting, index) => {
            const scale = setting.constraint?.type === "SCALE" ? setting.constraint.value : 1;
            console.error(`[Figma API]   \u{1F4C4} Setting ${index}: format=${setting.format}, scale=${scale}x, suffix=${setting.suffix || "none"}`);
          });
        } else {
          console.error(`[Figma API]   \u26A0\uFE0F No export settings found for icon "${node.name}"`);
        }
      }
      if (node.exportSettings && node.exportSettings.length > 0) {
        for (const exportSetting of node.exportSettings) {
          nodesToExport.push({ node, exportSetting });
          console.error(`[Figma API] \u2705 Added to export queue: "${node.name}" as ${exportSetting.format}`);
        }
      }
      if (node.children) {
        for (const child of node.children) {
          findExportableNodes(child);
        }
      }
    };
    console.error(`[Figma API] \u{1F50D} Scanning ${nodes.length} root nodes for export settings...`);
    for (const node of nodes) {
      console.error(`[Figma API] \u{1F4C1} Scanning node: "${node.name}" (${node.type})`);
      findExportableNodes(node);
    }
    if (nodesToExport.length === 0) {
      console.error(`[Figma API] \u274C No nodes with export settings found!`);
      console.error(`[Figma API] \u{1F4A1} Make sure your icons have export settings configured in Figma:`);
      console.error(`[Figma API]    1. Select the icon in Figma`);
      console.error(`[Figma API]    2. In the right panel, scroll to "Export" section`);
      console.error(`[Figma API]    3. Click "+" to add export settings`);
      console.error(`[Figma API]    4. Choose SVG format for icons`);
      return {
        downloaded: [],
        summary: { total: 0, successful: 0, failed: 0, skipped: 0 }
      };
    }
    console.error(`[Figma API] \u2705 Found ${nodesToExport.length} export tasks from ${nodes.length} nodes`);
    const exportGroups = /* @__PURE__ */ new Map();
    for (const item of nodesToExport) {
      const { exportSetting } = item;
      let scale = 1;
      if (exportSetting.constraint) {
        if (exportSetting.constraint.type === "SCALE") {
          scale = exportSetting.constraint.value;
        }
      }
      const format = exportSetting.format.toLowerCase();
      if (format === "svg") {
        scale = 1;
      }
      const groupKey = `${format}_${scale}`;
      if (!exportGroups.has(groupKey)) {
        exportGroups.set(groupKey, []);
      }
      exportGroups.get(groupKey).push(item);
    }
    console.error(`[Figma API] Grouped exports into ${exportGroups.size} batches by format/scale`);
    for (const [groupKey, groupItems] of exportGroups) {
      const [format, scaleStr] = groupKey.split("_");
      const scale = parseFloat(scaleStr || "1");
      console.error(`[Figma API] Processing group: ${format} at ${scale}x scale (${groupItems.length} items)`);
      const batchSize = 10;
      for (let i = 0; i < groupItems.length; i += batchSize) {
        const batch = groupItems.slice(i, i + batchSize);
        const nodeIds = batch.map((item) => item.node.id);
        try {
          const imageResponse = await this.getImages(fileKey, nodeIds, {
            format,
            scale,
            use_absolute_bounds: true
          });
          for (const { node, exportSetting } of batch) {
            const imageUrl = imageResponse.images[node.id];
            if (!imageUrl) {
              results.push({
                nodeId: node.id,
                nodeName: node.name.replace(/[/\\:*?"<>|]/g, "-").replace(/\s+/g, " ").trim(),
                filePath: "",
                exportSetting,
                success: false,
                error: "No image URL returned from Figma API"
              });
              continue;
            }
            const rawNodeName = node.name;
            const sanitizedNodeName = rawNodeName.replace(/[/\\:*?"<>|]/g, "-").replace(/\s+/g, " ").trim();
            const suffix = exportSetting.suffix || "";
            const extension = exportSetting.format.toLowerCase();
            let baseFilename;
            if (suffix) {
              baseFilename = `${sanitizedNodeName}${suffix}`;
            } else {
              if (scale === 1) {
                baseFilename = `${sanitizedNodeName}-x1`;
              } else {
                baseFilename = `${sanitizedNodeName}-x${scale}`;
              }
            }
            const filename = generateUniqueFilename(node, baseFilename, extension, exportSetting);
            const filePath = path.join(resolvedPath, filename);
            try {
              const downloadResponse = await axios.get(imageUrl, {
                responseType: "arraybuffer",
                timeout: 3e4,
                headers: {
                  "User-Agent": "Custom-Figma-MCP-Server/1.0.0"
                }
              });
              await fs.writeFile(filePath, downloadResponse.data);
              results.push({
                nodeId: node.id,
                nodeName: sanitizedNodeName,
                filePath,
                exportSetting,
                success: true
              });
              console.error(`[Figma API] Downloaded: ${filename} (${(downloadResponse.data.byteLength / 1024).toFixed(1)}KB)`);
            } catch (downloadError) {
              results.push({
                nodeId: node.id,
                nodeName: sanitizedNodeName,
                filePath,
                exportSetting,
                success: false,
                error: `Download failed: ${downloadError instanceof Error ? downloadError.message : String(downloadError)}`
              });
              console.error(`[Figma API] Failed to download ${filename}:`, downloadError);
            }
          }
        } catch (batchError) {
          console.error(`[Figma API] Batch failed for group ${groupKey}:`, batchError);
          for (const { node, exportSetting } of batch) {
            results.push({
              nodeId: node.id,
              nodeName: node.name.replace(/[/\\:*?"<>|]/g, "-").replace(/\s+/g, " ").trim(),
              filePath: "",
              exportSetting,
              success: false,
              error: `Batch API call failed: ${batchError instanceof Error ? batchError.message : String(batchError)}`
            });
          }
        }
        if (i + batchSize < groupItems.length) {
          await new Promise((resolve) => setTimeout(resolve, 100));
        }
      }
    }
    const summary = {
      total: results.length,
      successful: results.filter((r) => r.success).length,
      failed: results.filter((r) => !r.success).length,
      skipped: 0
      // We process all nodes with export settings
    };
    console.error(`[Figma API] Download completed: ${summary.successful}/${summary.total} successful`);
    let workspaceEnforcement = null;
    if (summary.successful > 0 && !options.skipWorkspaceEnforcement) {
      console.error(`[Figma API] \u{1F504} Starting workspace enforcement for ${summary.successful} successful downloads...`);
      try {
        workspaceEnforcement = await _FigmaApiService.enforceWorkspaceLocation(results, localPath);
        console.error(`[Figma API] \u{1F3AF} Export workspace enforcement completed successfully!`);
        console.error(`[Figma API]   \u2705 ${workspaceEnforcement.summary.alreadyCorrect} already in correct location`);
        console.error(`[Figma API]   \u{1F4E6} ${workspaceEnforcement.summary.moved} moved to workspace`);
        console.error(`[Figma API]   \u274C ${workspaceEnforcement.summary.failed} failed to move`);
        console.error(`[Figma API]   \u{1F4C1} Final location: ${workspaceEnforcement.finalLocation}`);
      } catch (enforcementError) {
        console.error(`[Figma API] \u274C Export workspace enforcement failed completely:`, enforcementError);
        console.error(`[Figma API] \u{1F504} Falling back to legacy recovery system...`);
        const expectedPaths = results.filter((r) => r.success).map((r) => r.filePath);
        if (expectedPaths.length > 0) {
          console.error(`[Figma API] \u{1F50D} Verifying ${expectedPaths.length} expected paths...`);
          const verification = await _FigmaApiService.verifyAssetsLocation(expectedPaths);
          console.error(`[Figma API] \u{1F4CA} Verification results: ${verification.summary.found} found, ${verification.summary.missing} missing`);
          if (verification.summary.missing > 0) {
            console.error(`[Figma API] \u26A0\uFE0F ${verification.summary.missing} export assets missing from expected location, attempting recovery...`);
            const recovery = await _FigmaApiService.findAndRecoverMissingAssets(results, resolvedPath);
            console.error(`[Figma API] \u{1F4CA} Recovery results: ${recovery.summary.recovered}/${recovery.summary.total} recovered`);
            if (recovery.summary.recovered > 0) {
              console.error(`[Figma API] \u{1F389} Successfully recovered ${recovery.summary.recovered} export assets to project directory!`);
              for (const recoveredAsset of recovery.recovered) {
                const resultIndex = results.findIndex((r) => r.nodeId === recoveredAsset.nodeId);
                if (resultIndex !== -1 && recoveredAsset.success && results[resultIndex]) {
                  results[resultIndex].filePath = recoveredAsset.newPath;
                  results[resultIndex].success = true;
                  console.error(`[Figma API] \u{1F4E6} Updated result path: ${recoveredAsset.oldPath} \u2192 ${recoveredAsset.newPath}`);
                }
              }
            } else {
              console.error(`[Figma API] \u26A0\uFE0F Recovery system could not locate missing assets`);
            }
          } else {
            console.error(`[Figma API] \u2705 All assets verified at expected locations`);
          }
        }
      }
    } else {
      console.error(`[Figma API] \u23ED\uFE0F Skipping workspace enforcement - no successful downloads`);
    }
    return {
      downloaded: results,
      summary,
      workspaceEnforcement: workspaceEnforcement ? {
        finalLocation: workspaceEnforcement.finalLocation,
        moved: workspaceEnforcement.summary.moved,
        workspaceSource: workspaceEnforcement.workspaceInfo.source,
        confidence: workspaceEnforcement.workspaceInfo.confidence
      } : null
    };
  }
  /**
   * Get comments for a Figma file
   */
  async getComments(fileKey) {
    if (!fileKey || typeof fileKey !== "string") {
      throw new FigmaApiError("File key is required and must be a string");
    }
    try {
      return await this.makeRequest(`/files/${fileKey}/comments`);
    } catch (error) {
      if (error instanceof FigmaApiError) {
        throw error;
      }
      throw new FigmaApiError(`Failed to get comments from file ${fileKey}: ${error}`);
    }
  }
  /**
   * Get OS-specific dangerous paths that should never be used for asset downloads
   */
  static getDangerousPaths() {
    const platform = os.platform();
    switch (platform) {
      case "win32":
        return [
          "C:\\",
          "C:\\Windows",
          "C:\\Program Files",
          "C:\\Program Files (x86)",
          "C:\\System32",
          "C:\\Users\\Public",
          "D:\\",
          "E:\\",
          // Also check for drive letters generically
          ...Array.from({ length: 26 }, (_, i) => String.fromCharCode(65 + i) + ":\\")
        ];
      case "darwin":
        return [
          "/",
          "/System",
          "/Library",
          "/usr",
          "/bin",
          "/sbin",
          "/etc",
          "/var",
          "/tmp",
          "/Applications",
          "/private"
        ];
      default:
        return [
          "/",
          "/bin",
          "/usr",
          "/etc",
          "/root",
          "/var",
          "/sys",
          "/proc",
          "/boot",
          "/dev",
          "/lib",
          "/sbin",
          "/tmp"
        ];
    }
  }
  /**
   * Check if a path is considered dangerous/system path for the current OS
   */
  static isDangerousPath(checkPath) {
    const dangerousPaths = this.getDangerousPaths();
    const normalizedCheckPath = path.normalize(checkPath);
    return dangerousPaths.some((dangerous) => {
      const normalizedDangerous = path.normalize(dangerous);
      return normalizedCheckPath === normalizedDangerous || normalizedCheckPath.startsWith(normalizedDangerous + path.sep);
    });
  }
  /**
   * Check if current working directory indicates a system root (cross-platform)
   */
  static isSystemRoot(dir) {
    const normalizedDir = path.normalize(dir);
    const platform = os.platform();
    switch (platform) {
      case "win32":
        return /^[A-Z]:\\?$/i.test(normalizedDir);
      default:
        return normalizedDir === path.sep || normalizedDir.length <= 1;
    }
  }
  /**
   * Get OS-appropriate search locations for missing assets
   */
  static getAssetSearchLocations() {
    const platform = os.platform();
    const homeDir = os.homedir();
    const cwd = process.cwd();
    const commonLocations = [
      homeDir,
      path.join(homeDir, "figma-workspace"),
      path.join(homeDir, "figma-workspace", "assets"),
      cwd,
      path.join(cwd, ".."),
      path.join(cwd, "assets"),
      path.join(cwd, "figma-assets")
    ];
    switch (platform) {
      case "win32":
        return [
          ...commonLocations,
          path.join(homeDir, "Downloads"),
          path.join(homeDir, "Desktop"),
          path.join(homeDir, "Documents"),
          "C:\\temp",
          "C:\\tmp"
          // Don't search system roots on Windows
        ];
      case "darwin":
        return [
          ...commonLocations,
          path.join(homeDir, "Downloads"),
          path.join(homeDir, "Desktop"),
          path.join(homeDir, "Documents"),
          "/tmp",
          // macOS specific locations
          path.join(homeDir, "Library", "Application Support")
        ];
      default:
        return [
          ...commonLocations,
          path.join(homeDir, "Downloads"),
          path.join(homeDir, "Desktop"),
          path.join(homeDir, "Documents"),
          "/tmp",
          // Only add root if we're not running as root user
          ...process.getuid && process.getuid() !== 0 ? ["/"] : [],
          "/assets",
          "/figma-assets"
        ];
    }
  }
  /**
   * Enhanced workspace detection specifically designed for Cursor IDE compatibility
   * This addresses the known Cursor bug where process.cwd() returns wrong directories
   */
  static getActualWorkspaceDirectory() {
    console.error(`[Figma API] \u{1F3AF} Enhanced workspace detection starting...`);
    console.error(`[Figma API] \u{1F4CA} Initial context: process.cwd()="${process.cwd()}", PWD="${process.env.PWD}"`);
    const candidates = [];
    const isCursorIDE = process.env.CURSOR_USER_DATA_DIR || process.env.CURSOR_CONFIG_DIR || process.env.VSCODE_IPC_HOOK_CLI || process.argv.some((arg) => arg.includes("cursor")) || !!process.env.CURSOR_DEBUG;
    if (isCursorIDE) {
      console.error(`[Figma API] \u{1F3AF} Cursor IDE detected - applying enhanced detection`);
    }
    const cursorSpecificSources = [
      { env: "WORKSPACE_FOLDER_PATHS", label: "Cursor Workspace Folders", priority: "ultra-high" },
      { env: "CURSOR_WORKSPACE_ROOT", label: "Cursor Workspace Root", priority: "high" },
      { env: "VSCODE_WORKSPACE_ROOT", label: "VS Code Workspace Root", priority: "high" }
    ];
    for (const source of cursorSpecificSources) {
      const envValue = process.env[source.env];
      if (envValue) {
        const workspacePaths = envValue.includes(";") ? envValue.split(";") : [envValue];
        for (const dir of workspacePaths) {
          const cleanDir = dir.trim();
          if (cleanDir && !this.isSystemRoot(cleanDir)) {
            try {
              fsSync.accessSync(cleanDir);
              if (this.isValidProjectDirectory(cleanDir)) {
                const confidence = source.priority === "ultra-high" ? "high" : "high";
                candidates.push({ dir: cleanDir, confidence, source: source.label });
                console.error(`[Figma API] \u2705 Found ${source.label}: ${cleanDir}`);
              }
            } catch {
              console.error(`[Figma API] \u26A0\uFE0F ${source.label} not accessible: ${cleanDir}`);
            }
          }
        }
      }
    }
    const highConfidenceSources = [
      { env: "PROJECT_ROOT", label: "Project Root" },
      { env: "WORKSPACE_ROOT", label: "Workspace Root" },
      { env: "npm_config_prefix", label: "NPM Project Root" },
      { env: "INIT_CWD", label: "Initial Working Directory" }
    ];
    for (const source of highConfidenceSources) {
      const dir = process.env[source.env];
      if (dir && !this.isSystemRoot(dir)) {
        try {
          fsSync.accessSync(dir);
          if (this.isValidProjectDirectory(dir)) {
            candidates.push({ dir, confidence: "high", source: source.label });
            console.error(`[Figma API] \u2705 Found ${source.label}: ${dir}`);
          }
        } catch {
          console.error(`[Figma API] \u26A0\uFE0F ${source.label} not accessible: ${dir}`);
        }
      }
    }
    const mediumConfidenceSources = [
      { env: "PWD", label: "Shell Working Directory" },
      { env: "OLDPWD", label: "Previous Working Directory" }
    ];
    for (const source of mediumConfidenceSources) {
      const dir = process.env[source.env];
      if (dir && !this.isSystemRoot(dir)) {
        try {
          fsSync.accessSync(dir);
          if (this.isValidProjectDirectory(dir)) {
            candidates.push({ dir, confidence: "medium", source: source.label });
            console.error(`[Figma API] \u2705 Found ${source.label}: ${dir}`);
          }
        } catch {
          console.error(`[Figma API] \u26A0\uFE0F ${source.label} not accessible: ${dir}`);
        }
      }
    }
    console.error(`[Figma API] \u{1F50D} Searching for project markers...`);
    const markerBasedDirs = this.findProjectDirectoryByMarkers();
    for (const dir of markerBasedDirs) {
      if (!candidates.some((c) => c.dir === dir)) {
        candidates.push({ dir, confidence: "medium", source: "Project Markers" });
        console.error(`[Figma API] \u2705 Found via project markers: ${dir}`);
      }
    }
    const processCwd = process.cwd();
    if (isCursorIDE && this.isSystemRoot(processCwd)) {
      console.error(`[Figma API] \u{1F6A8} Cursor bug detected: process.cwd() is system root (${processCwd}), ignoring`);
    } else if (!this.isSystemRoot(processCwd) && this.isValidProjectDirectory(processCwd)) {
      if (!candidates.some((c) => c.dir === processCwd)) {
        candidates.push({ dir: processCwd, confidence: "low", source: "Process Working Directory" });
        console.error(`[Figma API] \u2705 Valid process.cwd(): ${processCwd}`);
      }
    } else {
      console.error(`[Figma API] \u274C Invalid process.cwd(): ${processCwd}`);
    }
    candidates.sort((a, b) => {
      const confidenceOrder = { "high": 3, "medium": 2, "low": 1 };
      return confidenceOrder[b.confidence] - confidenceOrder[a.confidence];
    });
    console.error(`[Figma API] \u{1F50D} Workspace detection found ${candidates.length} candidates:`);
    candidates.forEach((candidate, index) => {
      console.error(`[Figma API]   ${index + 1}. ${candidate.dir} (${candidate.confidence} confidence, ${candidate.source})`);
    });
    if (candidates.length > 0) {
      const best = candidates[0];
      console.error(`[Figma API] \u2705 Selected workspace: ${best.dir} (${best.confidence} confidence)`);
      return { workspaceDir: best.dir, confidence: best.confidence, source: best.source };
    }
    if (isCursorIDE) {
      console.error(`[Figma API] \u{1F3AF} Cursor IDE fallback: searching common project locations`);
      const commonProjectLocations = [
        path.join(os.homedir(), "Desktop"),
        path.join(os.homedir(), "Documents"),
        path.join(os.homedir(), "Projects"),
        path.join(os.homedir(), "Development"),
        path.join(os.homedir(), "Code"),
        os.homedir()
      ];
      for (const baseDir of commonProjectLocations) {
        try {
          const entries = fsSync.readdirSync(baseDir, { withFileTypes: true });
          for (const entry of entries.slice(0, 10)) {
            if (entry.isDirectory()) {
              const projectCandidate = path.join(baseDir, entry.name);
              if (this.isValidProjectDirectory(projectCandidate)) {
                console.error(`[Figma API] \u{1F3AF} Found potential Cursor project: ${projectCandidate}`);
                return { workspaceDir: projectCandidate, confidence: "medium", source: "Cursor Project Search" };
              }
            }
          }
        } catch {
        }
      }
    }
    const fallback = path.join(os.homedir(), "figma-mcp-workspace");
    console.error(`[Figma API] \u{1F527} No valid workspace found, using enhanced fallback: ${fallback}`);
    try {
      fsSync.mkdirSync(fallback, { recursive: true });
      const packageJsonPath = path.join(fallback, "package.json");
      if (!fsSync.existsSync(packageJsonPath)) {
        fsSync.writeFileSync(packageJsonPath, JSON.stringify({
          name: "figma-mcp-workspace",
          version: "1.0.0",
          description: "Workspace for Figma MCP assets",
          private: true
        }, null, 2));
      }
      console.error(`[Figma API] \u2705 Created fallback workspace with package.json`);
    } catch (error) {
      console.error(`[Figma API] \u26A0\uFE0F Could not enhance fallback workspace:`, error);
    }
    return { workspaceDir: fallback, confidence: "low", source: "Enhanced Fallback" };
  }
  /**
   * Enforce assets are in the actual IDE workspace - move them if needed
   */
  static async enforceWorkspaceLocation(downloadResults, requestedPath) {
    console.error(`[Figma API] \u{1F3AF} Enforcing workspace location for assets...`);
    console.error(`[Figma API] \u{1F4E5} Input: ${downloadResults.length} download results, requested path: "${requestedPath}"`);
    const workspaceInfo = this.getActualWorkspaceDirectory();
    console.error(`[Figma API] \u{1F3E0} Detected workspace: "${workspaceInfo.workspaceDir}" (${workspaceInfo.confidence} confidence from ${workspaceInfo.source})`);
    const requestedBasename = path.basename(requestedPath);
    const workspaceTargetDir = path.resolve(workspaceInfo.workspaceDir, requestedBasename);
    console.error(`[Figma API] \u{1F4C1} Target workspace location: ${workspaceTargetDir}`);
    console.error(`[Figma API] \u{1F504} Assets to process: ${downloadResults.filter((r) => r.success).length} successful downloads`);
    const moved = [];
    const successfulDownloads = downloadResults.filter((r) => r.success);
    let alreadyCorrect = 0;
    let movedCount = 0;
    let failed = 0;
    for (const result of successfulDownloads) {
      const currentPath = result.filePath;
      const filename = path.basename(currentPath);
      const targetPath = path.join(workspaceTargetDir, filename);
      console.error(`[Figma API] \u{1F50D} Processing asset: ${result.nodeName}`);
      console.error(`[Figma API]   \u{1F4C1} Current path: ${currentPath}`);
      console.error(`[Figma API]   \u{1F3AF} Target path: ${targetPath}`);
      console.error(`[Figma API]   \u{1F4CB} Filename: ${filename}`);
      if (path.normalize(currentPath) === path.normalize(targetPath)) {
        console.error(`[Figma API] \u2705 Already in workspace: ${filename}`);
        alreadyCorrect++;
        continue;
      }
      try {
        await fs.access(currentPath);
      } catch {
        console.error(`[Figma API] \u26A0\uFE0F File not found at reported location: ${currentPath}`);
        const searchLocations = this.getAssetSearchLocations();
        let foundPath = null;
        for (const searchLoc of searchLocations) {
          try {
            const candidatePath = path.join(searchLoc, filename);
            await fs.access(candidatePath);
            const stat = await fs.stat(candidatePath);
            if (stat.size > 0) {
              foundPath = candidatePath;
              console.error(`[Figma API] \u{1F50D} Found ${filename} at: ${candidatePath}`);
              break;
            }
          } catch {
          }
        }
        if (!foundPath) {
          console.error(`[Figma API] \u274C Could not locate ${filename} for workspace enforcement`);
          moved.push({
            nodeId: result.nodeId,
            nodeName: result.nodeName,
            oldPath: currentPath,
            newPath: targetPath,
            success: false
          });
          failed++;
          continue;
        }
        result.filePath = foundPath;
      }
      try {
        await this.createDirectorySafely(workspaceTargetDir, requestedPath);
      } catch (dirError) {
        console.error(`[Figma API] \u274C Failed to create workspace directory: ${dirError}`);
        moved.push({
          nodeId: result.nodeId,
          nodeName: result.nodeName,
          oldPath: result.filePath,
          newPath: targetPath,
          success: false
        });
        failed++;
        continue;
      }
      try {
        const originalPath = result.filePath;
        console.error(`[Figma API] \u{1F504} Attempting to move: ${filename}`);
        console.error(`[Figma API]   \u{1F4E4} From: ${originalPath}`);
        console.error(`[Figma API]   \u{1F4E5} To: ${targetPath}`);
        let sourceStats;
        try {
          sourceStats = await fs.stat(originalPath);
          console.error(`[Figma API]   \u{1F4CA} Source file: ${Math.round(sourceStats.size / 1024)}KB`);
        } catch (statError) {
          throw new Error(`Source file does not exist: ${originalPath}`);
        }
        const targetDir = path.dirname(targetPath);
        try {
          await fs.mkdir(targetDir, { recursive: true });
        } catch (mkdirError) {
          console.error(`[Figma API] \u26A0\uFE0F Target directory creation failed:`, mkdirError);
        }
        let moveSuccess = false;
        let moveMethod = "";
        try {
          await fs.rename(originalPath, targetPath);
          moveSuccess = true;
          moveMethod = "atomic rename";
          console.error(`[Figma API] \u2705 Success via atomic rename: ${filename}`);
        } catch (renameError) {
          console.error(`[Figma API] \u26A0\uFE0F Atomic rename failed (likely cross-filesystem):`, renameError instanceof Error ? renameError.message : String(renameError));
          try {
            console.error(`[Figma API] \u{1F504} Trying copy + delete method...`);
            await fs.copyFile(originalPath, targetPath);
            const targetStats = await fs.stat(targetPath);
            if (targetStats.size !== sourceStats.size) {
              throw new Error(`Copy verification failed: size mismatch (${sourceStats.size} vs ${targetStats.size})`);
            }
            console.error(`[Figma API] \u2705 Copy verified: ${Math.round(targetStats.size / 1024)}KB`);
            await fs.unlink(originalPath);
            moveSuccess = true;
            moveMethod = "copy + delete";
            console.error(`[Figma API] \u2705 Success via copy + delete: ${filename}`);
          } catch (copyError) {
            console.error(`[Figma API] \u274C Copy + delete failed:`, copyError instanceof Error ? copyError.message : String(copyError));
            try {
              console.error(`[Figma API] \u{1F504} Trying streaming copy method...`);
              const readStream = (await import("fs")).createReadStream(originalPath);
              const writeStream = (await import("fs")).createWriteStream(targetPath);
              await new Promise((resolve, reject) => {
                readStream.pipe(writeStream);
                writeStream.on("finish", () => resolve());
                writeStream.on("error", reject);
                readStream.on("error", reject);
              });
              const streamTargetStats = await fs.stat(targetPath);
              if (streamTargetStats.size !== sourceStats.size) {
                throw new Error(`Streaming copy verification failed: size mismatch`);
              }
              await fs.unlink(originalPath);
              moveSuccess = true;
              moveMethod = "streaming copy";
              console.error(`[Figma API] \u2705 Success via streaming copy: ${filename}`);
            } catch (streamError) {
              const streamErrorMsg = streamError instanceof Error ? streamError.message : String(streamError);
              console.error(`[Figma API] \u274C All move methods failed for ${filename}:`, streamErrorMsg);
              throw new Error(`All move methods failed: ${streamErrorMsg}`);
            }
          }
        }
        if (moveSuccess) {
          try {
            const finalStats = await fs.stat(targetPath);
            console.error(`[Figma API] \u{1F389} Move completed via ${moveMethod}: ${filename} (${Math.round(finalStats.size / 1024)}KB)`);
            result.filePath = targetPath;
            moved.push({
              nodeId: result.nodeId,
              nodeName: result.nodeName,
              oldPath: originalPath,
              newPath: targetPath,
              success: true
            });
            movedCount++;
          } catch (verifyError) {
            throw new Error(`Move appeared successful but target file verification failed: ${verifyError instanceof Error ? verifyError.message : String(verifyError)}`);
          }
        } else {
          throw new Error("Unknown move failure - none of the methods succeeded");
        }
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        console.error(`[Figma API] \u274C Failed to move ${filename} to workspace: ${errorMsg}`);
        console.error(`[Figma API] \u{1F50D} This usually indicates a filesystem or permission issue`);
        moved.push({
          nodeId: result.nodeId,
          nodeName: result.nodeName,
          oldPath: result.filePath,
          newPath: targetPath,
          success: false
        });
        failed++;
      }
    }
    const summary = {
      total: successfulDownloads.length,
      alreadyCorrect,
      moved: movedCount,
      failed
    };
    console.error(`[Figma API] \u{1F3AF} Workspace enforcement completed:`);
    console.error(`[Figma API]   \u{1F4CA} ${summary.alreadyCorrect} already correct, ${summary.moved} moved, ${summary.failed} failed`);
    console.error(`[Figma API]   \u{1F4C1} Final location: ${workspaceTargetDir}`);
    return {
      finalLocation: workspaceTargetDir,
      moved,
      summary,
      workspaceInfo: { dir: workspaceInfo.workspaceDir, confidence: workspaceInfo.confidence, source: workspaceInfo.source }
    };
  }
};

// src/config/base.ts
var COMMON_OPTIMIZATIONS = {
  WEB_BASE: {
    enableCSSGeneration: true,
    enableSemanticAnalysis: true,
    enableAccessibilityInfo: true,
    enableResponsiveBreakpoints: true,
    enableDesignTokens: true,
    enableComponentVariants: true,
    enableInteractionStates: true,
    simplifyComplexPaths: true,
    optimizeForCodeGeneration: true
  },
  MOBILE_BASE: {
    enableCSSGeneration: false,
    enableSemanticAnalysis: true,
    enableAccessibilityInfo: true,
    enableResponsiveBreakpoints: true,
    enableDesignTokens: true,
    enableComponentVariants: true,
    enableInteractionStates: true,
    simplifyComplexPaths: true,
    optimizeForCodeGeneration: true,
    generateAdaptiveLayouts: true,
    generateDarkModeSupport: true
  },
  DESKTOP_BASE: {
    enableCSSGeneration: true,
    enableSemanticAnalysis: true,
    enableAccessibilityInfo: true,
    enableResponsiveBreakpoints: false,
    enableDesignTokens: true,
    enableComponentVariants: true,
    enableInteractionStates: true,
    simplifyComplexPaths: true,
    optimizeForCodeGeneration: true,
    generateMenus: true,
    generateNotifications: true
  }
};
var BASE_RULES = {
  MODERN_PATTERNS: {
    rule: "Use modern framework patterns",
    description: "Follow current best practices for the framework",
    priority: "critical",
    checks: ["Modern syntax", "Best practices", "Performance optimized"]
  },
  TYPESCRIPT: {
    rule: "TypeScript-first development",
    description: "Use TypeScript for type safety and better IDE support",
    priority: "critical",
    checks: ["Proper typing", "Interface definitions", "Type safety"]
  },
  ACCESSIBILITY: {
    rule: "Accessibility-first approach",
    description: "Ensure components are accessible by default",
    priority: "high",
    checks: ["ARIA labels", "Keyboard navigation", "Screen reader support"]
  },
  PERFORMANCE: {
    rule: "Optimize for performance",
    description: "Implement performance best practices",
    priority: "high",
    checks: ["Optimized rendering", "Memory efficient", "Fast interactions"]
  },
  TESTING: {
    rule: "Comprehensive testing strategy",
    description: "Test components and functionality thoroughly",
    priority: "medium",
    checks: ["Unit tests", "Integration tests", "User interaction tests"]
  }
};
var NAMING_CONVENTIONS = {
  PASCAL_CASE: "PascalCase",
  CAMEL_CASE: "camelCase",
  KEBAB_CASE: "kebab-case",
  SNAKE_CASE: "snake_case"
};

// src/config/rules.ts
var WEB_FRAMEWORK_BASE = {
  useTypeScript: true,
  componentNamingConvention: NAMING_CONVENTIONS.PASCAL_CASE,
  useTailwindCSS: true
};
var MOBILE_FRAMEWORK_BASE = {
  useTypeScript: true,
  componentNamingConvention: NAMING_CONVENTIONS.PASCAL_CASE,
  generateAccessibilitySupport: true
};
var DESKTOP_FRAMEWORK_BASE = {
  generateMenus: true,
  generateNotifications: true
};
var DEFAULT_RULES = {
  maxDepth: 10,
  includeHiddenNodes: false,
  includeLockedNodes: true,
  nodeTypeFilters: {
    include: [
      "DOCUMENT",
      "CANVAS",
      "FRAME",
      "GROUP",
      "TEXT",
      "RECTANGLE",
      "ELLIPSE",
      "VECTOR",
      "COMPONENT",
      "INSTANCE",
      "BOOLEAN_OPERATION",
      "STAR",
      "LINE",
      "REGULAR_POLYGON"
    ],
    exclude: ["SLICE", "STICKY"],
    prioritize: ["DOCUMENT", "CANVAS", "FRAME", "COMPONENT", "INSTANCE", "TEXT"]
  },
  aiOptimization: COMMON_OPTIMIZATIONS.WEB_BASE,
  contentEnhancement: {
    extractTextContent: true,
    analyzeImageContent: false,
    detectUIPatterns: true,
    identifyComponentHierarchy: true,
    extractLayoutConstraints: true,
    analyzeColorPalettes: true,
    extractTypographyStyles: true,
    detectSpacingPatterns: true
  },
  contextReduction: {
    removeRedundantProperties: true,
    simplifyNestedStructures: true,
    aggregateSimilarNodes: false,
    removeEmptyContainers: true,
    limitTextLength: 1e3,
    compressLargeArrays: true
  },
  frameworkOptimizations: {
    react: { ...WEB_FRAMEWORK_BASE, generateJSX: true, generateHooks: true },
    vue: { ...WEB_FRAMEWORK_BASE, generateSFC: true, useCompositionAPI: true },
    angular: { ...WEB_FRAMEWORK_BASE, generateComponent: true, useStandalone: true, useSignals: true },
    svelte: { ...WEB_FRAMEWORK_BASE, generateSvelteComponent: true },
    html: { ...WEB_FRAMEWORK_BASE, generateSemanticHTML: true, useCSS: true, generateAccessibleMarkup: true, useModernCSS: true },
    swiftui: { ...MOBILE_FRAMEWORK_BASE, generateViews: true, useViewBuilder: true, generateModifiers: true, useStateManagement: true, generateAdaptiveLayouts: true, generateDarkModeSupport: true },
    uikit: { ...MOBILE_FRAMEWORK_BASE, generateViewControllers: true, useProgrammaticLayout: true, useAutoLayout: true },
    electron: { ...DESKTOP_FRAMEWORK_BASE, componentNamingConvention: NAMING_CONVENTIONS.CAMEL_CASE, generateMainProcess: true, generateRendererProcess: true, useIPC: true, useContextIsolation: true },
    tauri: { ...DESKTOP_FRAMEWORK_BASE, componentNamingConvention: NAMING_CONVENTIONS.SNAKE_CASE, generateRustBackend: true, generateWebFrontend: true, useSystemWebView: true },
    nwjs: { ...DESKTOP_FRAMEWORK_BASE, componentNamingConvention: NAMING_CONVENTIONS.CAMEL_CASE, generateNodeBackend: true, generateWebFrontend: true, useChromiumAPI: true }
  },
  customRules: []
};
var getEnvironmentRules = () => {
  const isDev = process.env.NODE_ENV === "development";
  return {
    maxDepth: isDev ? 15 : 10,
    aiOptimization: {
      ...COMMON_OPTIMIZATIONS.WEB_BASE,
      enableComponentVariants: isDev,
      enableInteractionStates: isDev
    }
  };
};
var mergeRules = (base, override) => {
  return {
    ...base,
    ...override,
    aiOptimization: { ...base.aiOptimization, ...override.aiOptimization },
    contentEnhancement: { ...base.contentEnhancement, ...override.contentEnhancement },
    contextReduction: { ...base.contextReduction, ...override.contextReduction },
    frameworkOptimizations: { ...base.frameworkOptimizations, ...override.frameworkOptimizations }
  };
};

// src/processors/context-processor.ts
var ContextProcessor = class {
  rules;
  stats = {
    nodesProcessed: 0,
    nodesEnhanced: 0,
    rulesApplied: 0,
    processingTime: 0,
    errors: [],
    warnings: []
  };
  constructor(customRules) {
    const envRules = getEnvironmentRules();
    this.rules = mergeRules(DEFAULT_RULES, { ...envRules, ...customRules });
  }
  /**
   * Process a Figma node tree and enhance it with AI-optimized context
   */
  async processNode(node, context) {
    const startTime = Date.now();
    this.stats.nodesProcessed++;
    try {
      if (context.depth > this.rules.maxDepth) {
        this.stats.warnings.push(`Max depth exceeded for node ${node.id}`);
        return this.createMinimalNode(node);
      }
      if (!this.shouldIncludeNode(node)) {
        return this.createMinimalNode(node);
      }
      const enhancedNode = {
        ...node,
        cssProperties: {},
        semanticRole: void 0,
        accessibilityInfo: {},
        designTokens: [],
        componentVariants: [],
        interactionStates: [],
        layoutContext: this.createLayoutContext(node, context),
        // Add component relationships
        componentRelationships: this.createComponentRelationships(node, context)
      };
      if (this.rules.aiOptimization.enableCSSGeneration) {
        enhancedNode.cssProperties = this.generateCSSProperties(node, context);
      }
      if (this.rules.aiOptimization.enableSemanticAnalysis) {
        enhancedNode.semanticRole = this.analyzeSemanticRole(node, context);
      }
      if (this.rules.aiOptimization.enableAccessibilityInfo) {
        enhancedNode.accessibilityInfo = this.generateAccessibilityInfo(node, context);
      }
      if (this.rules.aiOptimization.enableDesignTokens) {
        enhancedNode.designTokens = this.extractDesignTokens(node, context);
      }
      if (this.rules.aiOptimization.enableComponentVariants) {
        enhancedNode.componentVariants = this.detectComponentVariants(node, context);
      }
      if (this.rules.aiOptimization.enableInteractionStates) {
        enhancedNode.interactionStates = this.generateInteractionStates(node, context);
      }
      await this.applyCustomRules(enhancedNode, context);
      if (node.children && context.depth < this.rules.maxDepth) {
        enhancedNode.children = await Promise.all(
          node.children.map(
            (child, index) => this.processNode(child, {
              ...context,
              parentNode: enhancedNode,
              depth: context.depth + 1,
              siblingIndex: index,
              totalSiblings: node.children?.length || 0
            })
          )
        );
      }
      this.applyContextReduction(enhancedNode);
      this.stats.nodesEnhanced++;
      return enhancedNode;
    } catch (error) {
      this.stats.errors.push(`Error processing node ${node.id}: ${error}`);
      return this.createMinimalNode(node);
    } finally {
      this.stats.processingTime += Date.now() - startTime;
    }
  }
  shouldIncludeNode(node) {
    if (!this.rules.includeHiddenNodes && node.visible === false) {
      return false;
    }
    if (!this.rules.includeLockedNodes && node.locked === true) {
      return false;
    }
    const { include, exclude } = this.rules.nodeTypeFilters;
    if (exclude.includes(node.type)) {
      return false;
    }
    if (include.length > 0 && !include.includes(node.type)) {
      return false;
    }
    return true;
  }
  createMinimalNode(node) {
    return {
      id: node.id,
      name: node.name,
      type: node.type,
      visible: node.visible,
      locked: node.locked
    };
  }
  createLayoutContext(node, context) {
    const position = context.totalSiblings === 1 ? "only" : context.siblingIndex === 0 ? "first" : context.siblingIndex === context.totalSiblings - 1 ? "last" : "middle";
    return {
      parentType: context.parentNode?.type || "DOCUMENT",
      siblingCount: context.totalSiblings,
      position,
      gridArea: this.detectGridArea(node, context),
      flexOrder: this.detectFlexOrder(node, context)
    };
  }
  createComponentRelationships(node, context) {
    const relationships = {};
    if (context.parentNode) {
      relationships.parent = {
        id: context.parentNode.id,
        name: context.parentNode.name,
        type: context.parentNode.type
      };
    }
    if (node.children && node.children.length > 0) {
      relationships.children = node.children.slice(0, 10).map((child) => ({
        id: child.id,
        name: child.name,
        type: child.type,
        role: this.detectChildRole(child, node)
      }));
    }
    if (context.parentNode?.children && context.totalSiblings > 1) {
      const siblings = context.parentNode.children.filter((sibling) => sibling.id !== node.id).slice(0, 5).map((sibling) => ({
        id: sibling.id,
        name: sibling.name,
        type: sibling.type
      }));
      if (siblings.length > 0) {
        relationships.siblings = siblings;
      }
    }
    if (node.componentId || node.type === "INSTANCE") {
      relationships.componentInstance = {
        componentId: node.componentId,
        overrides: node.componentProperties
      };
    }
    if (node.exportSettings && node.exportSettings.length > 0) {
      relationships.exportable = {
        hasExportSettings: true,
        formats: node.exportSettings.map((setting) => setting.format.toLowerCase()),
        category: this.detectExportCategory(node)
      };
    }
    return relationships;
  }
  detectChildRole(child, _parent) {
    const childName = child.name.toLowerCase();
    if (child.type === "TEXT") {
      if (childName.includes("title") || childName.includes("heading")) return "title";
      if (childName.includes("description") || childName.includes("body")) return "description";
      if (childName.includes("label")) return "label";
      if (childName.includes("caption")) return "caption";
    }
    if (this.isButton(child, childName)) return "action";
    if (this.isImage(child, childName)) return "visual";
    if (child.type === "FRAME" && childName.includes("content")) return "content";
    return void 0;
  }
  detectExportCategory(node) {
    const name = node.name.toLowerCase();
    if (name.includes("icon")) return "icon";
    if (name.includes("logo")) return "logo";
    if (name.includes("image") || name.includes("photo")) return "image";
    if (node.absoluteBoundingBox) {
      const { width, height } = node.absoluteBoundingBox;
      if (width <= 32 && height <= 32) return "icon";
      if (width > 200 || height > 200) return "image";
    }
    return "asset";
  }
  generateCSSProperties(node, _context) {
    const css = {};
    if (node.absoluteBoundingBox) {
      css.width = `${node.absoluteBoundingBox.width}px`;
      css.height = `${node.absoluteBoundingBox.height}px`;
    }
    if (node.layoutMode) {
      css.display = "flex";
      css.flexDirection = node.layoutMode === "HORIZONTAL" ? "row" : "column";
      if (node.primaryAxisAlignItems) {
        css.justifyContent = this.mapAxisAlign(node.primaryAxisAlignItems);
      }
      if (node.counterAxisAlignItems) {
        css.alignItems = this.mapAxisAlign(node.counterAxisAlignItems);
      }
      if (node.itemSpacing) {
        css.gap = `${node.itemSpacing}px`;
      }
    }
    if (node.paddingLeft || node.paddingRight || node.paddingTop || node.paddingBottom) {
      const top = node.paddingTop || 0;
      const right = node.paddingRight || 0;
      const bottom = node.paddingBottom || 0;
      const left = node.paddingLeft || 0;
      css.padding = `${top}px ${right}px ${bottom}px ${left}px`;
    }
    if (node.fills && node.fills.length > 0) {
      const fill = node.fills[0];
      if (fill && fill.visible !== false) {
        if (fill.type === "SOLID" && fill.color) {
          css.backgroundColor = this.colorToCSS(fill.color);
        } else if (fill.type.startsWith("GRADIENT_") && fill.gradientStops) {
          css.background = this.generateGradientCSS(fill);
        } else if (fill.type === "IMAGE" && fill.imageRef) {
          css.backgroundImage = `url(${fill.imageRef})`;
          if (fill.scaleMode) {
            css.backgroundSize = this.mapScaleMode(fill.scaleMode);
          }
        }
      }
    }
    if (node.cornerRadius !== void 0) {
      css.borderRadius = `${node.cornerRadius}px`;
    } else if (node.rectangleCornerRadii) {
      const [topLeft, topRight, bottomRight, bottomLeft] = node.rectangleCornerRadii;
      css.borderRadius = `${topLeft}px ${topRight}px ${bottomRight}px ${bottomLeft}px`;
    }
    if (node.strokes && node.strokes.length > 0) {
      const stroke = node.strokes[0];
      if (stroke && stroke.type === "SOLID" && stroke.color) {
        const strokeWeight = node.strokeWeight || 1;
        const strokeColor = this.colorToCSS(stroke.color);
        if (node.strokeAlign === "INSIDE") {
          css.boxShadow = `inset 0 0 0 ${strokeWeight}px ${strokeColor}`;
        } else if (node.strokeAlign === "OUTSIDE") {
          css.boxShadow = `0 0 0 ${strokeWeight}px ${strokeColor}`;
        } else {
          css.border = `${strokeWeight}px solid ${strokeColor}`;
        }
      }
    }
    if (node.individualStrokeWeights) {
      const { top, right, bottom, left } = node.individualStrokeWeights;
      if (node.strokes && node.strokes.length > 0) {
        const stroke = node.strokes[0];
        if (stroke && stroke.type === "SOLID" && stroke.color) {
          const strokeColor = this.colorToCSS(stroke.color);
          css.borderTop = top > 0 ? `${top}px solid ${strokeColor}` : "none";
          css.borderRight = right > 0 ? `${right}px solid ${strokeColor}` : "none";
          css.borderBottom = bottom > 0 ? `${bottom}px solid ${strokeColor}` : "none";
          css.borderLeft = left > 0 ? `${left}px solid ${strokeColor}` : "none";
        }
      }
    }
    if (node.strokeDashes && node.strokeDashes.length > 0) {
      css.borderStyle = "dashed";
    }
    if (node.opacity !== void 0 && node.opacity < 1) {
      css.opacity = node.opacity.toString();
    }
    if (node.blendMode && node.blendMode !== "NORMAL" && node.blendMode !== "PASS_THROUGH") {
      css.mixBlendMode = node.blendMode.toLowerCase().replace("_", "-");
    }
    if (node.layoutSizingHorizontal === "FILL") {
      css.flexGrow = "1";
    }
    if (node.layoutSizingVertical === "FILL") {
      css.alignSelf = "stretch";
    }
    if (node.layoutAlign) {
      switch (node.layoutAlign) {
        case "MIN":
          css.alignSelf = "flex-start";
          break;
        case "CENTER":
          css.alignSelf = "center";
          break;
        case "MAX":
          css.alignSelf = "flex-end";
          break;
        case "STRETCH":
          css.alignSelf = "stretch";
          break;
      }
    }
    if (node.type === "TEXT" && node.style) {
      css.fontSize = `${node.style.fontSize}px`;
      css.fontFamily = node.style.fontFamily;
      css.lineHeight = `${node.style.lineHeightPx}px`;
      css.letterSpacing = `${node.style.letterSpacing}px`;
      if (node.style.fontPostScriptName) {
        css.fontFamily = `"${node.style.fontPostScriptName}", ${css.fontFamily}`;
      }
      if (node.style.textDecoration && node.style.textDecoration !== "NONE") {
        css.textDecoration = node.style.textDecoration.toLowerCase().replace("_", "-");
      }
      if (node.style.textCase && node.style.textCase !== "ORIGINAL") {
        switch (node.style.textCase) {
          case "UPPER":
            css.textTransform = "uppercase";
            break;
          case "LOWER":
            css.textTransform = "lowercase";
            break;
          case "TITLE":
            css.textTransform = "capitalize";
            break;
          case "SMALL_CAPS":
          case "SMALL_CAPS_FORCED":
            css.fontVariant = "small-caps";
            break;
        }
      }
      if (node.style.paragraphSpacing) {
        css.marginBottom = `${node.style.paragraphSpacing}px`;
      }
      if (node.style.paragraphIndent) {
        css.textIndent = `${node.style.paragraphIndent}px`;
      }
      if (node.style.fills && node.style.fills.length > 0) {
        const textFill = node.style.fills[0];
        if (textFill && textFill.type === "SOLID" && textFill.color) {
          css.color = this.colorToCSS(textFill.color);
        }
      }
    }
    if (node.effects && node.effects.length > 0) {
      const dropShadows = [];
      const innerShadows = [];
      let layerBlur;
      let backgroundBlur;
      node.effects.forEach((effect) => {
        if (effect.visible === false) return;
        switch (effect.type) {
          case "DROP_SHADOW":
            const x = effect.offset?.x || 0;
            const y = effect.offset?.y || 0;
            const blur = effect.radius || 0;
            const spread = effect.spread || 0;
            const color = effect.color ? this.colorToCSS(effect.color) : "rgba(0,0,0,0.25)";
            dropShadows.push(`${x}px ${y}px ${blur}px ${spread}px ${color}`);
            break;
          case "INNER_SHADOW":
            const ix = effect.offset?.x || 0;
            const iy = effect.offset?.y || 0;
            const iblur = effect.radius || 0;
            const ispread = effect.spread || 0;
            const icolor = effect.color ? this.colorToCSS(effect.color) : "rgba(0,0,0,0.25)";
            innerShadows.push(`inset ${ix}px ${iy}px ${iblur}px ${ispread}px ${icolor}`);
            break;
          case "LAYER_BLUR":
            layerBlur = effect.radius || 0;
            break;
          case "BACKGROUND_BLUR":
            backgroundBlur = effect.radius || 0;
            break;
        }
      });
      const allShadows = [...innerShadows, ...dropShadows];
      if (allShadows.length > 0) {
        if (css.boxShadow) {
          css.boxShadow = `${css.boxShadow}, ${allShadows.join(", ")}`;
        } else {
          css.boxShadow = allShadows.join(", ");
        }
      }
      if (layerBlur !== void 0 || backgroundBlur !== void 0) {
        const filters = [];
        if (layerBlur !== void 0) {
          filters.push(`blur(${layerBlur}px)`);
        }
        if (backgroundBlur !== void 0) {
          css.backdropFilter = `blur(${backgroundBlur}px)`;
        }
        if (filters.length > 0) {
          css.filter = filters.join(" ");
        }
      }
    }
    return css;
  }
  analyzeSemanticRole(node, context) {
    const name = node.name.toLowerCase();
    if (this.isButton(node, name)) {
      return {
        type: "button",
        purpose: "interactive",
        variant: this.detectButtonVariant(node, name),
        state: this.detectComponentState(node, name)
      };
    }
    if (this.isInput(node, name)) {
      return {
        type: "input",
        purpose: "data-entry",
        inputType: this.detectInputType(node, name),
        required: name.includes("required") || name.includes("*")
      };
    }
    if (this.isNavigation(node, name, context)) {
      return {
        type: "navigation",
        purpose: "navigation",
        level: this.detectNavigationLevel(node, context)
      };
    }
    if (node.type === "TEXT") {
      const hierarchy = this.detectTextHierarchy(node);
      const contentType = this.detectContentType(node, name);
      return {
        type: "text",
        hierarchy,
        contentType,
        textAlign: this.detectTextAlignment(node)
      };
    }
    if (this.isList(node, name, context)) {
      return {
        type: "list",
        purpose: "content",
        listType: this.detectListType(node, name),
        itemCount: this.countListItems(node)
      };
    }
    if (this.isGrid(node, name, context)) {
      return {
        type: "grid",
        purpose: "layout",
        gridStructure: this.analyzeGridStructure(node),
        responsive: this.detectResponsiveBehavior(node)
      };
    }
    if (this.isCard(node, name, context)) {
      return {
        type: "card",
        purpose: "content",
        cardType: this.detectCardType(node, name),
        hasActions: this.hasCardActions(node)
      };
    }
    if (node.type === "FRAME" && node.children && node.children.length > 0) {
      const layoutPattern = this.detectLayoutPattern(node);
      return {
        type: "container",
        purpose: "layout",
        layoutPattern,
        semantic: this.detectContainerSemantic(node, name)
      };
    }
    if (this.isImage(node, name)) {
      return {
        type: "image",
        purpose: "visual",
        imageType: this.detectImageType(node, name),
        hasCaption: this.hasImageCaption(node, context)
      };
    }
    return void 0;
  }
  // Enhanced helper methods for semantic analysis
  isButton(node, name) {
    return name.includes("button") || name.includes("btn") || name.includes("cta") || node.type === "FRAME" && this.hasButtonCharacteristics(node);
  }
  hasButtonCharacteristics(node) {
    const hasRoundedCorners = Boolean(node.cornerRadius && node.cornerRadius > 0);
    const hasSolidBackground = Boolean(node.fills && node.fills.some((fill) => fill.type === "SOLID"));
    const hasClickableSize = Boolean(node.absoluteBoundingBox && node.absoluteBoundingBox.width >= 60 && node.absoluteBoundingBox.height >= 32);
    const hasTextChild = Boolean(node.children && node.children.some((child) => child.type === "TEXT"));
    return hasRoundedCorners && hasSolidBackground && hasClickableSize && hasTextChild;
  }
  detectButtonVariant(_node, name) {
    if (name.includes("primary")) return "primary";
    if (name.includes("secondary")) return "secondary";
    if (name.includes("outline")) return "outline";
    if (name.includes("ghost")) return "ghost";
    if (name.includes("link")) return "link";
    return "default";
  }
  detectComponentState(_node, name) {
    if (name.includes("disabled")) return "disabled";
    if (name.includes("hover")) return "hover";
    if (name.includes("active")) return "active";
    if (name.includes("focus")) return "focus";
    return "default";
  }
  isInput(_node, name) {
    return name.includes("input") || name.includes("field") || name.includes("textbox") || name.includes("textarea") || name.includes("select") || name.includes("dropdown");
  }
  detectInputType(_node, name) {
    if (name.includes("email")) return "email";
    if (name.includes("password")) return "password";
    if (name.includes("search")) return "search";
    if (name.includes("number")) return "number";
    if (name.includes("tel") || name.includes("phone")) return "tel";
    if (name.includes("url")) return "url";
    if (name.includes("date")) return "date";
    if (name.includes("textarea")) return "textarea";
    if (name.includes("select") || name.includes("dropdown")) return "select";
    return "text";
  }
  isNavigation(node, name, context) {
    return name.includes("nav") || name.includes("menu") || name.includes("header") || name.includes("breadcrumb") || this.hasNavigationPattern(node) && context.depth <= 2;
  }
  hasNavigationPattern(node) {
    if (node.layoutMode === "HORIZONTAL" && node.children) {
      const hasMultipleItems = node.children.length >= 2;
      const hasUniformItems = this.hasUniformChildren(node);
      return hasMultipleItems && hasUniformItems;
    }
    return false;
  }
  detectNavigationLevel(_node, context) {
    if (context.depth === 0) return 1;
    if (context.depth === 1) return 2;
    return 3;
  }
  isList(node, name, _context) {
    if (name.includes("list") || name.includes("items")) return true;
    if (node.children && node.children.length >= 2) {
      const hasRepeatingPattern = this.hasRepeatingPattern(node);
      const isVerticalLayout = node.layoutMode === "VERTICAL" || node.layoutMode === void 0 && this.hasVerticalArrangement(node);
      return hasRepeatingPattern && isVerticalLayout;
    }
    return false;
  }
  detectListType(node, name) {
    if (name.includes("ordered") || name.includes("numbered")) return "ordered";
    if (name.includes("unordered") || name.includes("bullet")) return "unordered";
    if (name.includes("description") || name.includes("definition")) return "description";
    if (node.children && node.children.length > 0) {
      const firstChild = node.children[0];
      if (firstChild && this.hasNumbering(firstChild)) return "ordered";
      if (firstChild && this.hasBulletPoints(firstChild)) return "unordered";
    }
    return "unordered";
  }
  countListItems(node) {
    if (!node.children) return 0;
    return node.children.filter(
      (child) => child.type === "FRAME" || child.type === "TEXT"
    ).length;
  }
  isGrid(node, name, _context) {
    if (name.includes("grid") || name.includes("gallery")) return true;
    if (node.children && node.children.length >= 4) {
      const gridStructure = this.analyzeGridStructure(node);
      return gridStructure.columns > 1 && gridStructure.rows > 1;
    }
    return false;
  }
  analyzeGridStructure(node) {
    if (!node.children || node.children.length === 0) {
      return { columns: 1, rows: 1, gap: 0 };
    }
    const children = [...node.children].sort((a, b) => {
      const aBox = a.absoluteBoundingBox;
      const bBox = b.absoluteBoundingBox;
      if (!aBox || !bBox) return 0;
      if (Math.abs(aBox.y - bBox.y) < 10) {
        return aBox.x - bBox.x;
      }
      return aBox.y - bBox.y;
    });
    if (children.length === 0) return { columns: 1, rows: 1, gap: 0 };
    const firstChild = children[0];
    if (!firstChild || !firstChild.absoluteBoundingBox) return { columns: 1, rows: 1, gap: 0 };
    const firstRowY = firstChild.absoluteBoundingBox.y;
    const firstRowItems = children.filter(
      (child) => child.absoluteBoundingBox && Math.abs(child.absoluteBoundingBox.y - firstRowY) < 10
    );
    const columns = firstRowItems.length;
    const rows = Math.ceil(children.length / columns);
    let gap = 0;
    if (firstRowItems.length > 1) {
      const first = firstRowItems[0]?.absoluteBoundingBox;
      const second = firstRowItems[1]?.absoluteBoundingBox;
      if (first && second) {
        gap = second.x - (first.x + first.width);
      }
    }
    return { columns, rows, gap: Math.max(0, gap) };
  }
  isCard(node, name, _context) {
    if (name.includes("card") || name.includes("tile")) return true;
    return this.hasCardCharacteristics(node);
  }
  hasCardCharacteristics(node) {
    const hasBackground = Boolean(node.fills && node.fills.length > 0);
    const hasBorder = Boolean(node.strokes && node.strokes.length > 0);
    const hasShadow = Boolean(node.effects && node.effects.some(
      (effect) => effect.type === "DROP_SHADOW" && effect.visible !== false
    ));
    const hasStructuredContent = Boolean(node.children && node.children.length >= 2);
    const hasRoundedCorners = Boolean(node.cornerRadius && node.cornerRadius > 0);
    return (hasBackground || hasBorder || hasShadow) && hasStructuredContent && hasRoundedCorners;
  }
  detectCardType(_node, name) {
    if (name.includes("product")) return "product";
    if (name.includes("profile") || name.includes("user")) return "profile";
    if (name.includes("article") || name.includes("blog")) return "article";
    if (name.includes("feature")) return "feature";
    return "content";
  }
  hasCardActions(node) {
    if (!node.children) return false;
    return node.children.some(
      (child) => this.isButton(child, child.name.toLowerCase()) || child.name.toLowerCase().includes("action") || child.name.toLowerCase().includes("link")
    );
  }
  detectLayoutPattern(node) {
    if (!node.children || node.children.length === 0) return "empty";
    if (node.layoutMode === "HORIZONTAL") {
      if (this.hasUniformChildren(node)) return "horizontal-list";
      if (this.hasSidebarPattern(node)) return "sidebar";
      return "horizontal-flow";
    }
    if (node.layoutMode === "VERTICAL") {
      if (this.hasHeaderBodyFooterPattern(node)) return "header-body-footer";
      if (this.hasUniformChildren(node)) return "vertical-list";
      return "vertical-flow";
    }
    if (this.hasGridPattern(node)) return "grid";
    if (this.hasAbsolutePositioning(node)) return "absolute";
    if (this.hasStackingPattern(node)) return "stack";
    return "free-form";
  }
  detectContainerSemantic(_node, name) {
    if (name.includes("header")) return "header";
    if (name.includes("footer")) return "footer";
    if (name.includes("sidebar")) return "aside";
    if (name.includes("main") || name.includes("content")) return "main";
    if (name.includes("section")) return "section";
    if (name.includes("article")) return "article";
    if (name.includes("nav")) return "nav";
    return "div";
  }
  isImage(node, name) {
    const hasImageFill = node.fills && node.fills.some((fill) => fill.type === "IMAGE");
    const isImageType = node.type === "RECTANGLE" || node.type === "ELLIPSE";
    const hasImageName = name.includes("image") || name.includes("photo") || name.includes("picture") || name.includes("avatar");
    return hasImageFill || isImageType && hasImageName;
  }
  detectImageType(_node, name) {
    if (name.includes("avatar") || name.includes("profile")) return "avatar";
    if (name.includes("logo")) return "logo";
    if (name.includes("icon")) return "icon";
    if (name.includes("hero") || name.includes("banner")) return "hero";
    if (name.includes("thumbnail")) return "thumbnail";
    return "content";
  }
  hasImageCaption(_node, context) {
    if (!context.parentNode?.children) return false;
    const nodeIndex = context.siblingIndex;
    const siblings = context.parentNode.children;
    if (nodeIndex + 1 < siblings.length) {
      const nextSibling = siblings[nodeIndex + 1];
      if (!nextSibling) return false;
      return nextSibling.type === "TEXT" && nextSibling.name.toLowerCase().includes("caption");
    }
    return false;
  }
  // Enhanced text hierarchy detection
  detectTextHierarchy(node) {
    if (node.type !== "TEXT" || !node.style) {
      return 0;
    }
    const fontSize = node.style.fontSize;
    const fontWeight = node.style.fontWeight || 400;
    const name = node.name.toLowerCase();
    if (name.includes("h1") || name.includes("heading 1")) return 1;
    if (name.includes("h2") || name.includes("heading 2")) return 2;
    if (name.includes("h3") || name.includes("heading 3")) return 3;
    if (name.includes("h4") || name.includes("heading 4")) return 4;
    if (name.includes("h5") || name.includes("heading 5")) return 5;
    if (name.includes("h6") || name.includes("heading 6")) return 6;
    if (name.includes("title") || name.includes("headline")) {
      if (fontSize >= 32) return 1;
      if (fontSize >= 24) return 2;
      return 3;
    }
    if (name.includes("subtitle") || name.includes("subheading")) {
      if (fontSize >= 20) return 3;
      return 4;
    }
    if (fontSize >= 36 || fontSize >= 28 && fontWeight >= 600) return 1;
    if (fontSize >= 28 || fontSize >= 24 && fontWeight >= 600) return 2;
    if (fontSize >= 24 || fontSize >= 20 && fontWeight >= 600) return 3;
    if (fontSize >= 20 || fontSize >= 18 && fontWeight >= 600) return 4;
    if (fontSize >= 18 || fontSize >= 16 && fontWeight >= 600) return 5;
    if (fontSize >= 16 && fontWeight >= 600) return 6;
    return 0;
  }
  detectContentType(_node, name) {
    if (name.includes("title") || name.includes("heading") || name.includes("headline")) return "title";
    if (name.includes("subtitle") || name.includes("subheading")) return "subtitle";
    if (name.includes("label")) return "label";
    if (name.includes("caption")) return "caption";
    if (name.includes("description") || name.includes("body")) return "body";
    if (name.includes("quote") || name.includes("blockquote")) return "quote";
    if (name.includes("code")) return "code";
    if (name.includes("link")) return "link";
    if (name.includes("date") || name.includes("time")) return "datetime";
    if (name.includes("price") || name.includes("cost")) return "price";
    if (name.includes("tag")) return "tag";
    return "text";
  }
  detectTextAlignment(node) {
    if (node.type !== "TEXT" || !node.style) return "left";
    const textAlign = node.style.textAlignHorizontal;
    if (textAlign === "CENTER") return "center";
    if (textAlign === "RIGHT") return "right";
    if (textAlign === "JUSTIFIED") return "justify";
    return "left";
  }
  generateAccessibilityInfo(node, context) {
    const info = {};
    if (node.name && !node.name.startsWith("Rectangle") && !node.name.startsWith("Ellipse")) {
      info.ariaLabel = node.name;
    }
    const semanticRole = this.analyzeSemanticRole(node, context);
    if (semanticRole?.type === "button" || semanticRole?.type === "input") {
      info.focusable = true;
      info.tabIndex = 0;
    }
    switch (semanticRole?.type) {
      case "button":
        info.ariaRole = "button";
        break;
      case "input":
        info.ariaRole = "textbox";
        break;
      case "navigation":
        info.ariaRole = "navigation";
        break;
      case "image":
        info.ariaRole = "img";
        info.altText = node.name;
        break;
    }
    return info;
  }
  extractDesignTokens(node, _context) {
    const tokens = [];
    if (node.fills && node.fills.length > 0) {
      node.fills.forEach((fill, index) => {
        if (fill.type === "SOLID" && fill.color) {
          tokens.push({
            name: `${node.name}-fill-${index}`,
            value: this.colorToCSS(fill.color),
            type: "color",
            category: "background"
          });
        }
      });
    }
    if (node.type === "TEXT" && node.style) {
      tokens.push({
        name: `${node.name}-font-size`,
        value: `${node.style.fontSize}px`,
        type: "typography",
        category: "font-size"
      });
      tokens.push({
        name: `${node.name}-line-height`,
        value: `${node.style.lineHeightPx}px`,
        type: "typography",
        category: "line-height"
      });
    }
    if (node.paddingLeft || node.paddingRight || node.paddingTop || node.paddingBottom) {
      const padding = [
        node.paddingTop || 0,
        node.paddingRight || 0,
        node.paddingBottom || 0,
        node.paddingLeft || 0
      ];
      tokens.push({
        name: `${node.name}-padding`,
        value: padding.map((p) => `${p}px`).join(" "),
        type: "spacing",
        category: "padding"
      });
    }
    if (node.effects && node.effects.length > 0) {
      const dropShadows = node.effects.filter((e) => e.type === "DROP_SHADOW" && e.visible !== false);
      const innerShadows = node.effects.filter((e) => e.type === "INNER_SHADOW" && e.visible !== false);
      dropShadows.forEach((shadow, index) => {
        const x = shadow.offset?.x || 0;
        const y = shadow.offset?.y || 0;
        const blur = shadow.radius || 0;
        const spread = shadow.spread || 0;
        const color = shadow.color ? this.colorToCSS(shadow.color) : "rgba(0,0,0,0.25)";
        tokens.push({
          name: `${node.name}-drop-shadow-${index}`,
          value: `${x}px ${y}px ${blur}px ${spread}px ${color}`,
          type: "shadow",
          category: "drop-shadow"
        });
      });
      innerShadows.forEach((shadow, index) => {
        const x = shadow.offset?.x || 0;
        const y = shadow.offset?.y || 0;
        const blur = shadow.radius || 0;
        const spread = shadow.spread || 0;
        const color = shadow.color ? this.colorToCSS(shadow.color) : "rgba(0,0,0,0.25)";
        tokens.push({
          name: `${node.name}-inner-shadow-${index}`,
          value: `inset ${x}px ${y}px ${blur}px ${spread}px ${color}`,
          type: "shadow",
          category: "inner-shadow"
        });
      });
    }
    if (node.strokes && node.strokes.length > 0 && node.strokeWeight) {
      const stroke = node.strokes[0];
      if (stroke && stroke.type === "SOLID" && stroke.color) {
        tokens.push({
          name: `${node.name}-border`,
          value: `${node.strokeWeight}px solid ${this.colorToCSS(stroke.color)}`,
          type: "border",
          category: "stroke"
        });
      }
    }
    if (node.cornerRadius !== void 0) {
      tokens.push({
        name: `${node.name}-border-radius`,
        value: `${node.cornerRadius}px`,
        type: "border",
        category: "radius"
      });
    }
    return tokens;
  }
  detectComponentVariants(node, _context) {
    const variants = [];
    if (node.type === "COMPONENT" || node.type === "INSTANCE") {
      variants.push({
        name: "default",
        properties: {},
        state: "default"
      });
      if (node.name.toLowerCase().includes("hover")) {
        variants.push({
          name: "hover",
          properties: { state: "hover" },
          state: "hover"
        });
      }
      if (node.name.toLowerCase().includes("disabled")) {
        variants.push({
          name: "disabled",
          properties: { state: "disabled" },
          state: "disabled"
        });
      }
    }
    return variants;
  }
  generateInteractionStates(node, context) {
    const states = [];
    const semanticRole = this.analyzeSemanticRole(node, context);
    if (semanticRole?.type === "button") {
      states.push({
        trigger: "hover",
        changes: { opacity: "0.8" },
        animation: { duration: "0.2s", easing: "ease-in-out" }
      });
      states.push({
        trigger: "click",
        changes: { transform: "scale(0.95)" },
        animation: { duration: "0.1s", easing: "ease-in-out" }
      });
    }
    if (semanticRole?.type === "input") {
      states.push({
        trigger: "focus",
        changes: {
          borderColor: "#007AFF",
          boxShadow: "0 0 0 2px rgba(0, 122, 255, 0.2)"
        },
        animation: { duration: "0.2s", easing: "ease-in-out" }
      });
    }
    return states;
  }
  async applyCustomRules(node, context) {
    const applicableRules = this.rules.customRules.filter((rule) => rule.enabled).filter((rule) => this.evaluateRuleCondition(rule.condition, node, context)).sort((a, b) => b.priority - a.priority);
    for (const rule of applicableRules) {
      try {
        await this.applyRuleAction(rule.action, node, context);
        this.stats.rulesApplied++;
      } catch (error) {
        this.stats.errors.push(`Error applying rule "${rule.name}": ${error}`);
      }
    }
  }
  evaluateRuleCondition(condition, node, _context) {
    if (condition.nodeType) {
      const types = Array.isArray(condition.nodeType) ? condition.nodeType : [condition.nodeType];
      if (!types.includes(node.type)) {
        return false;
      }
    }
    if (condition.nodeName) {
      if (condition.nodeName instanceof RegExp) {
        if (!condition.nodeName.test(node.name)) {
          return false;
        }
      } else {
        if (!node.name.toLowerCase().includes(condition.nodeName.toLowerCase())) {
          return false;
        }
      }
    }
    if (condition.hasChildren !== void 0) {
      const hasChildren = node.children && node.children.length > 0;
      if (condition.hasChildren !== hasChildren) {
        return false;
      }
    }
    if (condition.hasText !== void 0) {
      const hasText = node.type === "TEXT" || node.children && node.children.some((child) => child.type === "TEXT");
      if (condition.hasText !== hasText) {
        return false;
      }
    }
    if (condition.isComponent !== void 0) {
      const isComponent = node.type === "COMPONENT" || node.type === "INSTANCE";
      if (condition.isComponent !== isComponent) {
        return false;
      }
    }
    if (condition.hasAutoLayout !== void 0) {
      const hasAutoLayout = node.layoutMode !== void 0 && node.layoutMode !== "NONE";
      if (condition.hasAutoLayout !== hasAutoLayout) {
        return false;
      }
    }
    if (condition.customCondition) {
      return condition.customCondition(node);
    }
    return true;
  }
  async applyRuleAction(action, node, context) {
    switch (action.type) {
      case "enhance":
        Object.assign(node, action.parameters);
        break;
      case "transform":
        break;
      case "custom":
        if (action.customAction) {
          await action.customAction(node, context);
        }
        break;
    }
  }
  applyContextReduction(node) {
    if (!this.rules.contextReduction.removeRedundantProperties) {
      return;
    }
    Object.keys(node).forEach((key) => {
      const value = node[key];
      if (Array.isArray(value) && value.length === 0) {
        delete node[key];
      } else if (typeof value === "object" && value !== null && Object.keys(value).length === 0) {
        delete node[key];
      }
    });
    if (node.characters && node.characters.length > this.rules.contextReduction.limitTextLength) {
      node.characters = node.characters.substring(0, this.rules.contextReduction.limitTextLength) + "...";
    }
  }
  // Helper methods
  colorToCSS(color) {
    const r = Math.round(color.r * 255);
    const g = Math.round(color.g * 255);
    const b = Math.round(color.b * 255);
    const a = color.a;
    if (a === 1) {
      return `rgb(${r}, ${g}, ${b})`;
    } else {
      return `rgba(${r}, ${g}, ${b}, ${a})`;
    }
  }
  mapAxisAlign(align) {
    switch (align) {
      case "MIN":
        return "flex-start";
      case "CENTER":
        return "center";
      case "MAX":
        return "flex-end";
      case "SPACE_BETWEEN":
        return "space-between";
      default:
        return "flex-start";
    }
  }
  detectGridArea(_node, _context) {
    return void 0;
  }
  detectFlexOrder(_node, _context) {
    return void 0;
  }
  /**
   * Get processing statistics
   */
  getStats() {
    return { ...this.stats };
  }
  /**
   * Reset processing statistics
   */
  resetStats() {
    this.stats = {
      nodesProcessed: 0,
      nodesEnhanced: 0,
      rulesApplied: 0,
      processingTime: 0,
      errors: [],
      warnings: []
    };
  }
  /**
   * Update rules configuration
   */
  updateRules(newRules) {
    this.rules = mergeRules(this.rules, newRules);
  }
  /**
   * Process comments and associate them with nodes using coordinate matching
   * Uses bottom-up approach to find the most specific element for each comment
   */
  processCommentsForNode(node, comments) {
    const simplifiedInstructions = this.extractSimplifiedInstructions(comments);
    console.error(`[Context Processor] Processing comments for node: ${node.name} (${node.id})`);
    console.error(`  Available instructions: ${simplifiedInstructions.length}`);
    if (simplifiedInstructions.length > 0) {
      console.error(`[Context Processor] COORDINATE ANALYSIS:`);
      simplifiedInstructions.forEach((inst, instIndex) => {
        console.error(`  Comment ${instIndex}: "${inst.instruction}" at (${inst.coordinates.x}, ${inst.coordinates.y})`);
        this.debugElementCoordinates(node, inst.coordinates, `    `);
      });
    }
    const processedChildren = [];
    const usedInstructions = /* @__PURE__ */ new Set();
    if (node.children) {
      console.error(`  Processing ${node.children.length} children first...`);
      for (const child of node.children) {
        const processedChild = this.processCommentsForNode(child, comments);
        processedChildren.push(processedChild);
        if (processedChild.aiInstructions && processedChild.aiInstructions.length > 0) {
          console.error(`    Child ${child.name} claimed ${processedChild.aiInstructions.length} instructions`);
          processedChild.aiInstructions.forEach((inst) => {
            const index = simplifiedInstructions.findIndex(
              (si) => si.instruction === inst.instruction && si.coordinates && si.coordinates.x === inst.coordinates.x && si.coordinates.y === inst.coordinates.y
            );
            if (index >= 0) {
              usedInstructions.add(index);
              console.error(`      Marked instruction ${index} as used: "${inst.instruction}"`);
            }
          });
        }
        this.markUsedInstructionsRecursively(processedChild, simplifiedInstructions, usedInstructions);
      }
    }
    console.error(`  Instructions used by children: ${usedInstructions.size}`);
    const availableInstructions = simplifiedInstructions.filter((_, index) => !usedInstructions.has(index));
    console.error(`  Available instructions for this node: ${availableInstructions.length}`);
    const matchedInstructions = this.matchInstructionsToNode(node, availableInstructions);
    const enhancedNodeWithComments = {
      ...node,
      children: processedChildren.length > 0 ? processedChildren : void 0
    };
    if (matchedInstructions.length > 0) {
      console.error(`  Attaching ${matchedInstructions.length} instructions to ${node.name}`);
      enhancedNodeWithComments.aiInstructions = matchedInstructions;
      enhancedNodeWithComments.commentInstructions = matchedInstructions;
    }
    return enhancedNodeWithComments;
  }
  /**
   * Recursively mark instructions as used from all descendants
   */
  markUsedInstructionsRecursively(node, simplifiedInstructions, usedInstructions) {
    if (node.aiInstructions) {
      node.aiInstructions.forEach((inst) => {
        const index = simplifiedInstructions.findIndex(
          (si) => si.instruction === inst.instruction && si.coordinates && si.coordinates.x === inst.coordinates.x && si.coordinates.y === inst.coordinates.y
        );
        if (index >= 0) {
          usedInstructions.add(index);
        }
      });
    }
    if (node.children) {
      node.children.forEach((child) => {
        this.markUsedInstructionsRecursively(child, simplifiedInstructions, usedInstructions);
      });
    }
  }
  /**
   * Extract only essential data from comments: instruction + coordinates
   */
  extractSimplifiedInstructions(comments) {
    console.error(`[Context Processor] FULL COMMENT DATA DEBUG:`);
    comments.forEach((comment, index) => {
      console.error(`  Comment ${index}:`);
      console.error(`    message: "${comment.message}"`);
      console.error(`    client_meta:`, JSON.stringify(comment.client_meta, null, 2));
      if (comment.client_meta?.node_offset) {
        console.error(`    coordinates: (${comment.client_meta.node_offset.x}, ${comment.client_meta.node_offset.y})`);
      }
      if (comment.client_meta?.node_id) {
        console.error(`    target_node_id: ${comment.client_meta.node_id}`);
      }
    });
    const instructions = comments.filter((comment) => comment.message && comment.client_meta?.node_offset).map((comment) => ({
      instruction: comment.message,
      coordinates: {
        x: comment.client_meta.node_offset.x,
        y: comment.client_meta.node_offset.y
      },
      nodeId: comment.client_meta?.node_id
    }));
    console.error(`[Context Processor] Extracted ${instructions.length} instructions with coordinates:`);
    instructions.forEach((inst, index) => {
      console.error(`  ${index}: "${inst.instruction}" at (${inst.coordinates.x}, ${inst.coordinates.y}) node_id: ${inst.nodeId || "none"}`);
    });
    return instructions;
  }
  /**
   * Match instructions to nodes using precise coordinate matching with specificity priority
   */
  matchInstructionsToNode(node, instructions) {
    const matchedInstructions = [];
    console.error(`[Context Processor] Matching instructions for node: ${node.name} (${node.id})`);
    if (node.absoluteBoundingBox) {
      const bounds = node.absoluteBoundingBox;
      console.error(`  Node bounds: x=${bounds.x}, y=${bounds.y}, width=${bounds.width}, height=${bounds.height}`);
      console.error(`  Bounds range: x=${bounds.x} to ${bounds.x + bounds.width}, y=${bounds.y} to ${bounds.y + bounds.height}`);
    } else {
      console.error(`  Node has no absoluteBoundingBox`);
    }
    const directMatches = instructions.filter((inst) => inst.nodeId === node.id);
    console.error(`  Direct ID matches: ${directMatches.length}`);
    let coordinateMatches = [];
    if (node.absoluteBoundingBox && instructions.length > directMatches.length) {
      const bounds = node.absoluteBoundingBox;
      const nodeArea = bounds.width * bounds.height;
      coordinateMatches = instructions.filter(
        (inst) => !inst.nodeId || inst.nodeId !== node.id
        // Don't double-count direct matches
      ).filter((inst) => {
        const { x, y } = inst.coordinates;
        const exactMatch = x >= bounds.x && x <= bounds.x + bounds.width && y >= bounds.y && y <= bounds.y + bounds.height;
        if (exactMatch) {
          console.error(`    EXACT COORDINATE MATCH: "${inst.instruction}" at (${x}, ${y}) in node area ${nodeArea}px\xB2`);
          return true;
        }
        console.error(`    NO MATCH: "${inst.instruction}" at (${x}, ${y}) outside bounds`);
        return false;
      });
    }
    console.error(`  Precise coordinate matches: ${coordinateMatches.length}`);
    [...directMatches, ...coordinateMatches].forEach((match) => {
      const instructionType = this.categorizeInstruction(match.instruction);
      let confidence = 1;
      if (match.nodeId === node.id) {
        confidence = 1;
      } else if (node.absoluteBoundingBox) {
        const bounds = node.absoluteBoundingBox;
        const nodeArea = bounds.width * bounds.height;
        if (nodeArea < 1e4) {
          confidence = 0.95;
        } else if (nodeArea < 5e4) {
          confidence = 0.85;
        } else {
          confidence = 0.7;
        }
        console.error(`    Assigned confidence ${confidence} based on node area ${nodeArea}px\xB2`);
      } else {
        confidence = 0.5;
      }
      matchedInstructions.push({
        type: instructionType,
        instruction: match.instruction,
        author: "Designer",
        timestamp: (/* @__PURE__ */ new Date()).toISOString(),
        confidence,
        coordinates: match.coordinates
      });
    });
    console.error(`  Total matched instructions: ${matchedInstructions.length}`);
    return matchedInstructions;
  }
  /**
   * Debug helper: Recursively show all element bounds compared to comment coordinates
   */
  debugElementCoordinates(node, commentCoords, indent) {
    if (node.absoluteBoundingBox) {
      const bounds = node.absoluteBoundingBox;
      const isInside = commentCoords.x >= bounds.x && commentCoords.x <= bounds.x + bounds.width && commentCoords.y >= bounds.y && commentCoords.y <= bounds.y + bounds.height;
      const area = bounds.width * bounds.height;
      console.error(`${indent}${node.name} (${node.type}): bounds(${bounds.x},${bounds.y}) to (${bounds.x + bounds.width},${bounds.y + bounds.height}) area=${area}px\xB2 ${isInside ? "\u2713 CONTAINS" : "\u2717 outside"}`);
    } else {
      console.error(`${indent}${node.name} (${node.type}): NO BOUNDS`);
    }
    if (node.children) {
      node.children.forEach((child) => {
        this.debugElementCoordinates(child, commentCoords, indent + "  ");
      });
    }
  }
  /**
   * Simplified instruction categorization
   */
  categorizeInstruction(instruction) {
    const text = instruction.toLowerCase();
    if (text.includes("hover") || text.includes("click") || text.includes("tap") || text.includes("focus")) {
      return "interaction";
    }
    if (text.includes("animate") || text.includes("animation") || text.includes("transition") || text.includes("fade") || text.includes("slide") || text.includes("bounce")) {
      return "animation";
    }
    if (text.includes("show") || text.includes("hide") || text.includes("toggle") || text.includes("enable") || text.includes("disable")) {
      return "behavior";
    }
    return "general";
  }
  /**
   * Extract all node IDs from a node tree for comment filtering
   */
  extractAllNodeIds(node) {
    const nodeIds = [node.id];
    if (node.children) {
      node.children.forEach((child) => {
        nodeIds.push(...this.extractAllNodeIds(child));
      });
    }
    return nodeIds;
  }
  /**
   * Generate optimized data structure for AI code generation
   * Removes redundant and non-valuable information, focuses on development needs
   */
  optimizeForAI(node) {
    const optimized = {
      // Core identification
      id: node.id,
      name: node.name,
      type: node.type
    };
    if (node.visible === false) optimized.visible = false;
    if (node.children && node.children.length > 0) {
      optimized.children = node.children.map(
        (child) => this.optimizeForAI(child)
      );
    }
    if (node.absoluteBoundingBox) {
      optimized.bounds = {
        x: node.absoluteBoundingBox.x,
        y: node.absoluteBoundingBox.y,
        width: node.absoluteBoundingBox.width,
        height: node.absoluteBoundingBox.height
      };
    }
    if (node.cssProperties && Object.keys(node.cssProperties).length > 0) {
      optimized.css = this.cleanCSSProperties(node.cssProperties);
    }
    const imageInfo = this.detectExportableImage(node);
    if (imageInfo) {
      optimized.image = imageInfo;
      if (imageInfo.category === "icon") optimized.type = "ICON";
      if (imageInfo.category === "image") optimized.type = "IMAGE";
    }
    if (node.semanticRole) {
      optimized.role = node.semanticRole;
    }
    if (node.accessibilityInfo && Object.keys(node.accessibilityInfo).length > 0) {
      optimized.accessibility = node.accessibilityInfo;
    }
    if (node.designTokens && node.designTokens.length > 0) {
      optimized.tokens = node.designTokens.map((token) => ({
        name: token.name,
        value: token.value,
        type: token.type
      }));
    }
    if (node.interactionStates && node.interactionStates.length > 0) {
      optimized.interactions = node.interactionStates;
    }
    if (node.type === "TEXT" && node.characters) {
      optimized.text = node.characters;
      if (node.style) {
        optimized.textStyle = {
          fontFamily: node.style.fontFamily,
          fontSize: node.style.fontSize,
          lineHeight: node.style.lineHeightPx
        };
      }
    }
    if (node.layoutMode) {
      optimized.layout = {
        mode: node.layoutMode,
        direction: node.layoutMode === "HORIZONTAL" ? "row" : "column",
        gap: node.itemSpacing,
        padding: this.simplifyPadding(node)
      };
    }
    if (node.componentRelationships) {
      const relationships = {};
      if (node.componentRelationships.parent) {
        relationships.parent = {
          name: node.componentRelationships.parent.name,
          type: node.componentRelationships.parent.type
        };
      }
      if (node.componentRelationships.children && node.componentRelationships.children.length > 0) {
        relationships.children = node.componentRelationships.children.map((child) => ({
          name: child.name,
          type: child.type,
          role: child.role
        }));
      }
      if (node.componentRelationships.componentInstance) {
        relationships.component = node.componentRelationships.componentInstance;
      }
      if (node.componentRelationships.exportable?.hasExportSettings) {
        relationships.exportable = node.componentRelationships.exportable;
      }
      if (Object.keys(relationships).length > 0) {
        optimized.relationships = relationships;
      }
    }
    if (node.aiInstructions && node.aiInstructions.length > 0) {
      optimized.instructions = node.aiInstructions.map((inst) => ({
        type: inst.type,
        instruction: inst.instruction,
        confidence: inst.confidence
      }));
    }
    return optimized;
  }
  /**
   * Clean CSS properties - remove redundant and keep only development-relevant ones
   */
  cleanCSSProperties(css) {
    const essential = [
      "width",
      "height",
      "padding",
      "margin",
      "gap",
      "backgroundColor",
      "color",
      "fontSize",
      "fontFamily",
      "borderRadius",
      "border",
      "boxShadow",
      "display",
      "flexDirection",
      "justifyContent",
      "alignItems"
    ];
    const cleaned = {};
    essential.forEach((prop) => {
      if (css[prop] && css[prop] !== "0px" && css[prop] !== "none") {
        cleaned[prop] = css[prop];
      }
    });
    return Object.keys(cleaned).length > 0 ? cleaned : void 0;
  }
  /**
   * Simplify padding to a single property
   */
  simplifyPadding(node) {
    if (!node.paddingTop && !node.paddingRight && !node.paddingBottom && !node.paddingLeft) {
      return void 0;
    }
    const top = node.paddingTop || 0;
    const right = node.paddingRight || 0;
    const bottom = node.paddingBottom || 0;
    const left = node.paddingLeft || 0;
    if (top === right && right === bottom && bottom === left) {
      return `${top}px`;
    }
    return `${top}px ${right}px ${bottom}px ${left}px`;
  }
  /**
   * Detect ONLY nodes with explicit Figma export settings - no heuristics
   * Following Figma API specification: only export what's marked for export
   */
  detectExportableImage(node) {
    const hasExportSettings = node.exportSettings && node.exportSettings.length > 0;
    if (!hasExportSettings) {
      return null;
    }
    const formats = [];
    for (const setting of node.exportSettings) {
      const format = setting.format.toLowerCase();
      let scale = 1;
      if (setting.constraint) {
        if (setting.constraint.type === "SCALE") {
          scale = setting.constraint.value;
        }
      }
      if (format === "svg" || scale === 1) {
        formats.push(format);
      } else {
        formats.push(`${format}@${scale}x`);
      }
    }
    let category = "icon";
    const hasImageFill = node.fills && node.fills.some(
      (fill) => fill.type === "IMAGE" && fill.imageRef
    );
    if (hasImageFill) {
      category = "image";
    } else {
      const name = node.name.toLowerCase();
      if (name.includes("logo") || name.includes("brand")) {
        category = "logo";
      } else {
        category = "icon";
      }
    }
    return {
      category,
      formats: [...new Set(formats)],
      // Remove duplicates
      isExportable: true
    };
  }
  // Helper methods for pattern detection
  hasUniformChildren(node) {
    if (!node.children || node.children.length < 2) return false;
    const firstChild = node.children[0];
    if (!firstChild) return false;
    const firstType = firstChild.type;
    const firstSize = firstChild.absoluteBoundingBox;
    return node.children.every((child) => {
      const childSize = child.absoluteBoundingBox;
      const sameType = child.type === firstType;
      const similarSize = firstSize && childSize && Math.abs(firstSize.width - childSize.width) < 20 && Math.abs(firstSize.height - childSize.height) < 20;
      return sameType && similarSize;
    });
  }
  hasRepeatingPattern(node) {
    if (!node.children || node.children.length < 2) return false;
    const firstChild = node.children[0];
    if (!firstChild) return false;
    const pattern = this.analyzeNodeStructure(firstChild);
    return node.children.slice(1).every(
      (child) => this.matchesStructurePattern(child, pattern)
    );
  }
  hasVerticalArrangement(node) {
    if (!node.children || node.children.length < 2) return false;
    const sorted = [...node.children].sort((a, b) => {
      const aBox = a.absoluteBoundingBox;
      const bBox = b.absoluteBoundingBox;
      if (!aBox || !bBox) return 0;
      return aBox.y - bBox.y;
    });
    for (let i = 1; i < sorted.length; i++) {
      const prevNode = sorted[i - 1];
      const currNode = sorted[i];
      const prev = prevNode?.absoluteBoundingBox;
      const curr = currNode?.absoluteBoundingBox;
      if (!prev || !curr) continue;
      if (curr.y <= prev.y + prev.height * 0.5) return false;
    }
    return true;
  }
  hasNumbering(node) {
    if (node.type !== "TEXT" || !node.characters) return false;
    const text = node.characters.trim();
    const numberPatterns = [
      /^\d+\./,
      // 1. 2. 3.
      /^\d+\)/,
      // 1) 2) 3)
      /^\(\d+\)/,
      // (1) (2) (3)
      /^[ivx]+\./i,
      // i. ii. iii.
      /^[a-z]\./
      // a. b. c.
    ];
    return numberPatterns.some((pattern) => pattern.test(text));
  }
  hasBulletPoints(node) {
    if (node.type !== "TEXT" || !node.characters) return false;
    const text = node.characters.trim();
    const bulletPatterns = [
      /^•/,
      /^·/,
      /^‣/,
      /^⁃/,
      // Unicode bullets
      /^-/,
      /^\*/,
      /^\+/
      // ASCII bullets
    ];
    return bulletPatterns.some((pattern) => pattern.test(text));
  }
  hasSidebarPattern(node) {
    if (!node.children || node.children.length !== 2) return false;
    const first = node.children[0];
    const second = node.children[1];
    if (!first || !second) return false;
    const firstBox = first.absoluteBoundingBox;
    const secondBox = second.absoluteBoundingBox;
    if (!firstBox || !secondBox) return false;
    const firstIsNarrow = firstBox.width < secondBox.width * 0.5;
    const secondIsNarrow = secondBox.width < firstBox.width * 0.5;
    return firstIsNarrow || secondIsNarrow;
  }
  hasHeaderBodyFooterPattern(node) {
    if (!node.children || node.children.length < 3) return false;
    const sorted = [...node.children].sort((a, b) => {
      const aBox = a.absoluteBoundingBox;
      const bBox = b.absoluteBoundingBox;
      if (!aBox || !bBox) return 0;
      return aBox.y - bBox.y;
    });
    const heights = sorted.map((child) => child.absoluteBoundingBox?.height || 0);
    if (heights.length < 3) return false;
    const [headerHeight, ...bodyAndFooter] = heights;
    const footerHeight = bodyAndFooter[bodyAndFooter.length - 1];
    const bodyHeights = bodyAndFooter.slice(0, -1);
    const maxBodyHeight = Math.max(...bodyHeights);
    return (headerHeight || 0) < maxBodyHeight && (footerHeight || 0) < maxBodyHeight;
  }
  hasGridPattern(node) {
    if (!node.children || node.children.length < 4) return false;
    const structure = this.analyzeGridStructure(node);
    return structure.columns > 1 && structure.rows > 1;
  }
  hasAbsolutePositioning(node) {
    if (!node.children || node.children.length === 0) return false;
    const boxes = node.children.map((child) => child.absoluteBoundingBox).filter((box) => box !== void 0);
    if (boxes.length < 2) return false;
    for (let i = 0; i < boxes.length; i++) {
      for (let j = i + 1; j < boxes.length; j++) {
        const box1 = boxes[i];
        const box2 = boxes[j];
        const overlapX = Math.max(0, Math.min(box1.x + box1.width, box2.x + box2.width) - Math.max(box1.x, box2.x));
        const overlapY = Math.max(0, Math.min(box1.y + box1.height, box2.y + box2.height) - Math.max(box1.y, box2.y));
        const overlapArea = overlapX * overlapY;
        const box1Area = box1.width * box1.height;
        const box2Area = box2.width * box2.height;
        const minArea = Math.min(box1Area, box2Area);
        if (overlapArea > minArea * 0.25) {
          return true;
        }
      }
    }
    return false;
  }
  hasStackingPattern(node) {
    if (!node.children || node.children.length < 2) return false;
    const centerPoints = node.children.map((child) => {
      const box = child.absoluteBoundingBox;
      return box ? {
        x: box.x + box.width / 2,
        y: box.y + box.height / 2
      } : null;
    }).filter((point) => point !== null);
    if (centerPoints.length < 2) return false;
    const [first, ...rest] = centerPoints;
    const threshold = 50;
    return rest.every(
      (point) => Math.abs(point.x - first.x) < threshold && Math.abs(point.y - first.y) < threshold
    );
  }
  analyzeNodeStructure(node) {
    return {
      type: node.type,
      hasText: node.type === "TEXT" || node.children && node.children.some((child) => child.type === "TEXT"),
      hasImage: node.fills && node.fills.some((fill) => fill.type === "IMAGE"),
      childCount: node.children ? node.children.length : 0,
      hasBackground: node.fills && node.fills.length > 0,
      hasCornerRadius: node.cornerRadius && node.cornerRadius > 0
    };
  }
  matchesStructurePattern(node, pattern) {
    const structure = this.analyzeNodeStructure(node);
    return structure.type === pattern.type && structure.hasText === pattern.hasText && structure.hasImage === pattern.hasImage && Math.abs(structure.childCount - pattern.childCount) <= 1 && structure.hasBackground === pattern.hasBackground;
  }
  detectResponsiveBehavior(node) {
    if (!node.children || node.children.length === 0) return false;
    const hasAutoLayout = node.layoutMode !== void 0 && node.layoutMode !== "NONE";
    const hasFlexibleSizing = node.children.some(
      (child) => child.layoutSizingHorizontal === "FILL" || child.layoutSizingVertical === "FILL" || child.layoutGrow !== void 0 && child.layoutGrow > 0
    );
    const hasResponsiveConstraints = node.children.some(
      (child) => child.constraints?.horizontal === "LEFT_RIGHT" || child.constraints?.horizontal === "SCALE" || child.constraints?.vertical === "TOP_BOTTOM" || child.constraints?.vertical === "SCALE"
    );
    return hasAutoLayout || hasFlexibleSizing || hasResponsiveConstraints;
  }
  generateGradientCSS(fill) {
    if (!fill.gradientStops || fill.gradientStops.length === 0) {
      return "";
    }
    const stops = fill.gradientStops.map((stop) => `${this.colorToCSS(stop.color)} ${Math.round(stop.position * 100)}%`).join(", ");
    switch (fill.type) {
      case "GRADIENT_LINEAR":
        let angle = "180deg";
        if (fill.gradientHandlePositions && fill.gradientHandlePositions.length >= 2) {
          const start = fill.gradientHandlePositions[0];
          const end = fill.gradientHandlePositions[1];
          if (start && end) {
            const deltaX = end.x - start.x;
            const deltaY = end.y - start.y;
            const angleRad = Math.atan2(deltaY, deltaX);
            angle = `${Math.round(angleRad * 180 / Math.PI + 90)}deg`;
          }
        }
        return `linear-gradient(${angle}, ${stops})`;
      case "GRADIENT_RADIAL":
        return `radial-gradient(circle, ${stops})`;
      case "GRADIENT_ANGULAR":
        return `conic-gradient(${stops})`;
      case "GRADIENT_DIAMOND":
        return `radial-gradient(ellipse, ${stops})`;
      default:
        return `linear-gradient(${stops})`;
    }
  }
  mapScaleMode(scaleMode) {
    switch (scaleMode) {
      case "FILL":
        return "cover";
      case "FIT":
        return "contain";
      case "TILE":
        return "repeat";
      case "STRETCH":
        return "100% 100%";
      default:
        return "cover";
    }
  }
};

// src/config/frameworks/react.ts
var reactRules = {
  aiOptimization: {
    ...COMMON_OPTIMIZATIONS.WEB_BASE,
    enableComponentVariants: true,
    enableInteractionStates: true
  },
  frameworkOptimizations: {
    react: {
      generateJSX: true,
      useStyledComponents: false,
      useTailwindCSS: true,
      generateHooks: true,
      generatePropTypes: false,
      useTypeScript: true,
      componentNamingConvention: NAMING_CONVENTIONS.PASCAL_CASE,
      generateStorybook: false,
      implementationRules: {
        modernPatterns: {
          ...BASE_RULES.MODERN_PATTERNS,
          rule: "Function components with hooks",
          checks: ["useState/useEffect", "Custom hooks", "No class components"]
        },
        typeScript: {
          ...BASE_RULES.TYPESCRIPT,
          checks: ["Interface props", "Typed state", "Event handlers typed"]
        },
        performance: {
          ...BASE_RULES.PERFORMANCE,
          rule: "React.memo + useCallback optimization",
          checks: ["React.memo wrapping", "useCallback functions", "useMemo calculations"]
        },
        stateManagement: {
          rule: "Context API for global state",
          description: "React Context + useReducer for complex state",
          priority: "medium",
          checks: ["Context providers", "useReducer complex state", "Custom hooks"]
        },
        accessibility: {
          ...BASE_RULES.ACCESSIBILITY,
          checks: ["ARIA labels", "useId hook", "Keyboard support", "Screen readers"]
        },
        testing: {
          ...BASE_RULES.TESTING,
          rule: "React Testing Library approach",
          checks: ["User-focused tests", "Accessibility queries", "Async testing"]
        },
        react19: {
          rule: "React 19 features",
          description: "Server Components + useOptimistic",
          priority: "medium",
          checks: ["Server Components", "use() hook", "useOptimistic UI"]
        }
      }
    }
  }
};

// src/config/frameworks/vue.ts
var vueRules = {
  aiOptimization: {
    ...COMMON_OPTIMIZATIONS.WEB_BASE,
    enableComponentVariants: true,
    enableInteractionStates: true
  },
  frameworkOptimizations: {
    vue: {
      generateSFC: true,
      useCompositionAPI: true,
      useScoped: true,
      generateProps: true,
      useTypeScript: true,
      componentNamingConvention: NAMING_CONVENTIONS.PASCAL_CASE,
      implementationRules: {
        modernPatterns: {
          ...BASE_RULES.MODERN_PATTERNS,
          rule: "Composition API with script setup",
          checks: ["<script setup>", "Composables", "Reactive refs"]
        },
        typeScript: {
          ...BASE_RULES.TYPESCRIPT,
          checks: ["defineProps types", "defineEmits types", "Reactive types"]
        },
        performance: {
          ...BASE_RULES.PERFORMANCE,
          rule: "Reactivity optimization",
          checks: ["computed values", "watch effects", "shallowRef"]
        },
        stateManagement: {
          rule: "Pinia for state management",
          description: "Pinia stores with composition API",
          priority: "medium",
          checks: ["Pinia stores", "Store composition", "Action methods"]
        },
        accessibility: BASE_RULES.ACCESSIBILITY,
        testing: {
          ...BASE_RULES.TESTING,
          rule: "Vue Test Utils approach",
          checks: ["Component mounting", "Props testing", "Event testing"]
        }
      }
    }
  }
};

// src/config/frameworks/angular.ts
var angularRules = {
  aiOptimization: {
    ...COMMON_OPTIMIZATIONS.WEB_BASE,
    enableComponentVariants: true,
    enableInteractionStates: true
  },
  frameworkOptimizations: {
    angular: {
      generateComponent: true,
      useStandalone: true,
      generateModule: false,
      useSignals: true,
      useTypeScript: true,
      componentNamingConvention: NAMING_CONVENTIONS.PASCAL_CASE,
      implementationRules: {
        modernPatterns: {
          ...BASE_RULES.MODERN_PATTERNS,
          rule: "Standalone components with signals",
          checks: ["Standalone components", "Signals API", "Control flow syntax"]
        },
        typeScript: BASE_RULES.TYPESCRIPT,
        performance: {
          ...BASE_RULES.PERFORMANCE,
          rule: "OnPush strategy and signals",
          checks: ["OnPush change detection", "Signals", "TrackBy functions"]
        },
        stateManagement: {
          rule: "NgRx with signals",
          description: "NgRx store with signals integration",
          priority: "medium",
          checks: ["NgRx store", "Effects", "Signal store"]
        },
        accessibility: BASE_RULES.ACCESSIBILITY,
        testing: {
          ...BASE_RULES.TESTING,
          rule: "Angular testing utilities",
          checks: ["TestBed setup", "Component testing", "Service testing"]
        }
      }
    }
  }
};

// src/config/frameworks/svelte.ts
var svelteRules = {
  aiOptimization: {
    ...COMMON_OPTIMIZATIONS.WEB_BASE,
    enableComponentVariants: true,
    enableInteractionStates: true
  },
  frameworkOptimizations: {
    svelte: {
      generateSvelteComponent: true,
      useTypeScript: true,
      useStores: false,
      componentNamingConvention: NAMING_CONVENTIONS.PASCAL_CASE,
      implementationRules: {
        modernPatterns: {
          ...BASE_RULES.MODERN_PATTERNS,
          rule: "Svelte 5+ with runes",
          checks: ["$state runes", "Reactive declarations", "Component composition"]
        },
        typeScript: BASE_RULES.TYPESCRIPT,
        performance: {
          ...BASE_RULES.PERFORMANCE,
          rule: "Svelte compilation optimization",
          checks: ["Reactive updates", "Tree shaking", "Bundle optimization"]
        },
        stateManagement: {
          rule: "Svelte stores and context",
          description: "Writable stores and context API",
          priority: "medium",
          checks: ["Writable stores", "Context API", "Reactive stores"]
        },
        accessibility: BASE_RULES.ACCESSIBILITY,
        testing: {
          ...BASE_RULES.TESTING,
          rule: "Svelte testing library",
          checks: ["Component testing", "Store testing", "User interactions"]
        }
      }
    }
  }
};

// src/config/frameworks/html.ts
var CRITICAL_ACCURACY = {
  priority: "critical",
  rule: "Exact Figma fidelity"
};
var HIGH_MODERN = {
  priority: "high",
  rule: "Modern CSS patterns"
};
var MEDIUM_ENHANCEMENT = {
  priority: "medium",
  rule: "UI enhancements"
};
var htmlRules = {
  aiOptimization: {
    ...COMMON_OPTIMIZATIONS.WEB_BASE,
    enableComponentVariants: false,
    enableInteractionStates: true,
    enableDesignTokens: true
  },
  frameworkOptimizations: {
    html: {
      generateSemanticHTML: true,
      useCSS: true,
      useTailwindCSS: true,
      generateAccessibleMarkup: true,
      useModernCSS: true,
      implementationRules: {
        // CRITICAL: Figma Fidelity
        metadataFidelity: {
          ...CRITICAL_ACCURACY,
          description: "Apply exact Figma values: padding, margins, fonts, colors, dimensions",
          checks: ["Exact padding", "Exact margins", "Exact font-sizes", "Exact colors", "Exact dimensions"]
        },
        typographyPrecision: {
          ...CRITICAL_ACCURACY,
          description: "Exact typography with CSS variables",
          checks: ["Exact font-size", "Exact line-height", "Exact letter-spacing", "CSS variables"]
        },
        colorAccuracy: {
          ...CRITICAL_ACCURACY,
          description: "Exact colors with CSS custom properties",
          checks: ["Exact hex/rgba", "CSS variables", "Consistent system"]
        },
        // CRITICAL: CSS Variables System
        cssVariables: {
          ...CRITICAL_ACCURACY,
          rule: "CSS custom properties system",
          description: "Systematic design tokens with semantic naming",
          checks: [
            "Color tokens: --color-primary, --text-primary, --bg-surface",
            "Typography: --font-size-*, --line-height-*",
            "Spacing: --space-xs/sm/md/lg, --radius-sm/md/lg",
            "Effects: --shadow-sm/md/lg, semantic naming"
          ]
        },
        // HIGH: Layout & Structure  
        flexibleContainers: {
          ...HIGH_MODERN,
          description: "Flexible layouts: children 100% width, containers max-width",
          checks: ["Children 100% width", "Container max-width", "Flex: 1 patterns"]
        },
        semanticHTML: {
          ...HIGH_MODERN,
          description: "Semantic HTML5 + BEM methodology",
          checks: ["<section>/<article>/<header>", "BEM: block__element--modifier", "Accessibility"]
        },
        responsiveDefault: {
          ...HIGH_MODERN,
          description: "Mobile-first responsive with CSS variables",
          checks: ["Mobile-first", "Breakpoint variables", "Responsive tokens"]
        },
        modernCSS: {
          ...HIGH_MODERN,
          description: "CSS Grid, Flexbox, logical properties, container queries",
          checks: ["CSS Grid 2D", "Flexbox 1D", "Logical properties", "Container queries"]
        },
        marginConflicts: {
          ...HIGH_MODERN,
          description: "Clean spacing: zero margins on flex children, container gaps",
          checks: ["Zero flex margins", "Container gaps", "Clean spacing"]
        },
        noInlineStyles: {
          ...HIGH_MODERN,
          description: "External CSS only, class-based styling",
          checks: ["External CSS", "Class names", "No inline styles", "Maintainable"]
        },
        // MEDIUM: Enhancements
        borderTechnique: {
          ...MEDIUM_ENHANCEMENT,
          description: "box-shadow: 0 0 0 1px for pixel-perfect borders",
          checks: ["Box-shadow borders", "Consistent rendering", "Pixel-perfect"]
        },
        animationIntegration: {
          ...MEDIUM_ENHANCEMENT,
          description: "Hover effects and transitions with CSS variables",
          checks: ["CSS variable transitions", "Hover effects", "Consistent timing"]
        },
        // CRITICAL: Validation
        validationChecklist: {
          ...CRITICAL_ACCURACY,
          rule: "Quality assurance checklist",
          description: "Verify fidelity, responsiveness, and modern practices",
          checks: [
            "\u2713 Dimensions match Figma exactly",
            "\u2713 Colors use CSS variables with exact values",
            "\u2713 Typography exact + CSS variables in :root",
            "\u2713 Responsive: mobile/tablet/desktop",
            "\u2713 Container containment, no overflow",
            "\u2713 Semantic HTML + accessibility",
            "\u2713 Hover/animations work + external CSS",
            "\u2713 BEM methodology + modern CSS features"
          ]
        }
      }
    }
  }
};

// src/config/frameworks/swiftui.ts
var swiftuiRules = {
  aiOptimization: {
    ...COMMON_OPTIMIZATIONS.MOBILE_BASE,
    enableCSSGeneration: false
  },
  frameworkOptimizations: {
    swiftui: {
      generateViews: true,
      useViewBuilder: true,
      generateModifiers: true,
      useObservableObject: true,
      useStateManagement: true,
      generatePreviewProvider: true,
      useEnvironmentObjects: false,
      componentNamingConvention: NAMING_CONVENTIONS.PASCAL_CASE,
      generateSFSymbols: true,
      useNativeColors: true,
      generateAdaptiveLayouts: true,
      useAsyncImage: true,
      generateNavigationViews: true,
      useToolbarModifiers: true,
      generateAnimations: true,
      useGeometryReader: false,
      generateDarkModeSupport: true,
      useTabViews: true,
      generateListViews: true,
      useScrollViews: true,
      generateFormViews: true,
      implementationRules: {
        modernPatterns: {
          ...BASE_RULES.MODERN_PATTERNS,
          rule: "SwiftUI 5.0+ patterns",
          checks: ["@State/@Observable", "ViewBuilder", "Modifiers"]
        },
        stateManagement: {
          rule: "SwiftUI state management",
          description: "@State, @Binding, @Observable for state",
          priority: "critical",
          checks: ["@State local", "@Binding shared", "@Observable data"]
        },
        layout: {
          rule: "Adaptive layout system",
          description: "HStack/VStack, LazyGrid, adaptive sizing",
          priority: "high",
          checks: ["Flexible layouts", "Device adaptation", "Safe areas"]
        },
        navigation: {
          rule: "Modern navigation patterns",
          description: "NavigationStack, TabView, Sheet presentation",
          priority: "high",
          checks: ["NavigationStack", "Programmatic navigation", "Modal presentation"]
        },
        accessibility: {
          ...BASE_RULES.ACCESSIBILITY,
          checks: ["VoiceOver support", "Dynamic Type", "Accessibility modifiers"]
        },
        performance: {
          ...BASE_RULES.PERFORMANCE,
          rule: "SwiftUI performance optimization",
          checks: ["LazyLoading", "Identity tracking", "View updates"]
        },
        testing: {
          ...BASE_RULES.TESTING,
          rule: "SwiftUI testing strategy",
          checks: ["Preview testing", "UI tests", "Unit tests"]
        }
      }
    }
  }
};

// src/config/frameworks/uikit.ts
var uikitRules = {
  aiOptimization: {
    ...COMMON_OPTIMIZATIONS.MOBILE_BASE,
    enableCSSGeneration: false
  },
  frameworkOptimizations: {
    uikit: {
      generateViewControllers: true,
      useStoryboards: false,
      useProgrammaticLayout: true,
      useAutoLayout: true,
      generateXIBFiles: false,
      useStackViews: true,
      generateConstraints: true,
      useSwiftUIInterop: true,
      componentNamingConvention: NAMING_CONVENTIONS.PASCAL_CASE,
      generateDelegatePatterns: true,
      useModernConcurrency: true,
      generateAccessibilitySupport: true,
      implementationRules: {
        modernPatterns: {
          ...BASE_RULES.MODERN_PATTERNS,
          rule: "Modern UIKit with Swift concurrency",
          checks: ["async/await", "@MainActor", "Structured concurrency"]
        },
        programmaticLayout: {
          rule: "Programmatic Auto Layout",
          description: "NSLayoutConstraint and UIStackView patterns",
          priority: "critical",
          checks: ["Auto Layout", "UIStackView", "Constraint activation"]
        },
        swiftuiInterop: {
          rule: "SwiftUI-UIKit integration",
          description: "UIHostingController and UIViewRepresentable",
          priority: "high",
          checks: ["UIHostingController", "UIViewRepresentable", "Coordinator pattern"]
        },
        delegatePatterns: {
          rule: "Modern delegate patterns",
          description: "Protocol-oriented delegates with weak references",
          priority: "high",
          checks: ["Weak delegates", "Protocol design", "Table view patterns"]
        },
        accessibility: {
          ...BASE_RULES.ACCESSIBILITY,
          checks: ["VoiceOver", "Dynamic Type", "Accessibility traits", "Custom actions"]
        },
        performance: {
          ...BASE_RULES.PERFORMANCE,
          rule: "UIKit performance optimization",
          checks: ["Table prefetching", "Image caching", "Memory management"]
        },
        testing: {
          ...BASE_RULES.TESTING,
          rule: "UIKit testing strategy",
          checks: ["XCTest", "UI testing", "Mock delegates"]
        }
      }
    }
  }
};

// src/config/frameworks/electron.ts
var electronRules = {
  aiOptimization: {
    ...COMMON_OPTIMIZATIONS.DESKTOP_BASE,
    enableCSSGeneration: true,
    enableResponsiveBreakpoints: true
  },
  frameworkOptimizations: {
    electron: {
      generateMainProcess: true,
      generateRendererProcess: true,
      useIPC: true,
      useWebSecurity: true,
      generateMenus: true,
      useNativeDialogs: true,
      generateUpdater: true,
      useContextIsolation: true,
      componentNamingConvention: NAMING_CONVENTIONS.CAMEL_CASE,
      generateNotifications: true,
      useCrashReporter: false,
      generateTrayIcon: false,
      useProtocolHandlers: false,
      implementationRules: {
        modernPatterns: {
          ...BASE_RULES.MODERN_PATTERNS,
          rule: "Main/Renderer process separation",
          checks: ["Context isolation", "Preload scripts", "Secure IPC"]
        },
        security: {
          rule: "Electron security best practices",
          description: "Context isolation, CSP, and secure defaults",
          priority: "critical",
          checks: ["Context isolation", "Node integration disabled", "CSP headers"]
        },
        ipcCommunication: {
          rule: "Secure IPC patterns",
          description: "Type-safe IPC with proper validation",
          priority: "high",
          checks: ["Typed IPC channels", "Input validation", "Error handling"]
        },
        nativeIntegration: {
          rule: "Native OS integration",
          description: "Menus, notifications, and system dialogs",
          priority: "medium",
          checks: ["Application menus", "System notifications", "File dialogs"]
        },
        performance: {
          ...BASE_RULES.PERFORMANCE,
          checks: ["Memory management", "Process optimization", "Resource loading"]
        },
        testing: {
          ...BASE_RULES.TESTING,
          rule: "Electron testing strategy",
          checks: ["Spectron tests", "Unit tests", "Main process tests"]
        }
      }
    }
  }
};

// src/config/frameworks/tauri.ts
var tauriRules = {
  aiOptimization: {
    ...COMMON_OPTIMIZATIONS.DESKTOP_BASE,
    enableCSSGeneration: true,
    enableResponsiveBreakpoints: false
  },
  frameworkOptimizations: {
    tauri: {
      generateRustBackend: true,
      generateWebFrontend: true,
      useSystemWebView: true,
      generateCommands: true,
      useEventSystem: true,
      generatePlugins: false,
      useSidecar: false,
      componentNamingConvention: NAMING_CONVENTIONS.SNAKE_CASE,
      generateUpdater: true,
      useFilesystem: true,
      generateNotifications: true,
      useSystemTray: false,
      generateMenus: true,
      implementationRules: {
        modernPatterns: {
          ...BASE_RULES.MODERN_PATTERNS,
          rule: "Rust backend with web frontend",
          checks: ["Tauri commands", "System WebView", "Rust/JS interop"]
        },
        security: {
          rule: "WebView security configuration",
          description: "Secure WebView with CSP and allowlist",
          priority: "critical",
          checks: ["Content Security Policy", "API allowlist", "Secure contexts"]
        },
        communication: {
          rule: "Frontend-backend communication",
          description: "Tauri invoke API and event system",
          priority: "high",
          checks: ["Invoke API", "Event system", "Type-safe commands"]
        },
        nativeIntegration: {
          rule: "Native OS integration",
          description: "Tauri plugins for OS functionality",
          priority: "medium",
          checks: ["Filesystem access", "Notifications", "System integration"]
        },
        performance: {
          ...BASE_RULES.PERFORMANCE,
          rule: "Bundle optimization",
          checks: ["System WebView", "Rust performance", "Small bundles"]
        },
        testing: {
          ...BASE_RULES.TESTING,
          rule: "Tauri testing strategy",
          checks: ["Rust unit tests", "WebView tests", "Integration tests"]
        }
      }
    }
  }
};

// src/config/frameworks/nwjs.ts
var nwjsRules = {
  aiOptimization: {
    ...COMMON_OPTIMIZATIONS.DESKTOP_BASE,
    enableCSSGeneration: true,
    enableResponsiveBreakpoints: false
  },
  frameworkOptimizations: {
    nwjs: {
      generateNodeBackend: true,
      generateWebFrontend: true,
      useChromiumAPI: true,
      generateMenus: true,
      useNativeModules: true,
      generateManifest: true,
      useClipboard: true,
      componentNamingConvention: NAMING_CONVENTIONS.CAMEL_CASE,
      generateFileAccess: true,
      useShell: true,
      generateScreenCapture: false,
      useTrayIcon: false,
      implementationRules: {
        modernPatterns: {
          ...BASE_RULES.MODERN_PATTERNS,
          rule: "Unified Node.js and DOM context",
          checks: ["Node.js modules in browser", "Direct file system access", "Chromium APIs"]
        },
        manifestConfiguration: {
          rule: "Package.json manifest configuration",
          description: "App properties and window settings",
          priority: "critical",
          checks: ["package.json setup", "Window configuration", "App permissions"]
        },
        nodeIntegration: {
          rule: "Node.js API integration",
          description: "Direct Node.js module access in web pages",
          priority: "high",
          checks: ["require() in browser", "File system APIs", "OS modules"]
        },
        chromiumFeatures: {
          rule: "Chromium-specific features",
          description: "Native browser capabilities and DevTools",
          priority: "high",
          checks: ["DevTools access", "Window management", "Native dialogs"]
        },
        nativeIntegration: {
          rule: "Native system integration",
          description: "Menus, clipboard, and shell access",
          priority: "medium",
          checks: ["Native menus", "Clipboard API", "Shell commands"]
        },
        performance: {
          ...BASE_RULES.PERFORMANCE,
          rule: "NW.js performance optimization",
          checks: ["Package optimization", "Memory management", "Startup performance"]
        },
        testing: {
          ...BASE_RULES.TESTING,
          rule: "NW.js testing strategy",
          checks: ["Node.js testing", "Browser testing", "Integration tests"]
        }
      }
    }
  }
};

// src/config/frameworks/index.ts
var frameworks = {
  react: reactRules,
  vue: vueRules,
  angular: angularRules,
  svelte: svelteRules,
  html: htmlRules,
  swiftui: swiftuiRules,
  uikit: uikitRules,
  electron: electronRules,
  tauri: tauriRules,
  nwjs: nwjsRules
};
function getFrameworkRules(framework) {
  return frameworks[framework];
}

// src/index.ts
dotenv.config();
var ShowFrameworksSchema = z.object({});
var GetFigmaDataSchema = z.object({
  fileKey: z.string().optional().describe("The Figma file key (optional if url provided)"),
  url: z.string().optional().describe("Full Figma URL with file and node selection (alternative to fileKey + nodeId)"),
  nodeId: z.string().optional().describe("Specific node ID to fetch (optional, extracted from url if provided)"),
  depth: z.number().min(1).max(10).default(5).describe("Maximum depth to traverse"),
  framework: z.enum(["react", "vue", "angular", "svelte", "html", "swiftui", "uikit", "electron", "tauri", "nwjs"]).describe("Target framework - REQUIRED (use select_framework first)"),
  includeImages: z.boolean().default(false).describe("Whether to include image URLs"),
  selectionOnly: z.boolean().default(false).describe("DEPRECATED: No longer needed. Select more specific elements in Figma if getting unintended content."),
  customRules: z.record(z.any()).optional().describe("Custom processing rules")
}).refine((data) => data.fileKey || data.url, {
  message: "Either fileKey or url must be provided"
});
var DownloadFigmaImagesSchema = z.object({
  fileKey: z.string().optional().describe("The Figma file key (optional if url provided)"),
  url: z.string().optional().describe("Full Figma URL with file and node selection - will scan selected area for ALL export assets"),
  nodeId: z.string().optional().describe("Specific node ID to scan for export assets (optional, extracted from url if provided)"),
  localPath: z.string().describe("Local directory path to save images (will be created if it does not exist)"),
  scale: z.number().min(0.5).max(4).default(2).optional().describe("Fallback export scale for images if no export settings found"),
  format: z.enum(["jpg", "png", "svg", "pdf"]).default("svg").optional().describe("Fallback image format if no export settings found")
}).refine((data) => data.fileKey || data.url, {
  message: "Either fileKey or url must be provided"
});
var ProcessDesignCommentsSchema = z.object({
  url: z.string().describe("Figma URL to scan for comments (full URL from browser)"),
  framework: z.enum(["react", "vue", "angular", "svelte", "html"]).describe("Target framework for code suggestions")
});
var CheckReferenceSchema = z.object({
  assetsPath: z.string().describe("Path to assets folder containing reference.png file"),
  framework: z.enum(["react", "vue", "angular", "svelte", "html"]).optional().describe("Target framework for development context (optional)")
});
var CustomFigmaMcpServer = class _CustomFigmaMcpServer {
  server;
  figmaApi;
  contextProcessor;
  config;
  // Centralized workflow constants
  static WORKFLOW_SEQUENCE = "show_frameworks \u2192 Design data \u2192 Comments \u2192 Assets download \u2192 Reference analysis \u2192 Code generation";
  constructor(config) {
    this.config = config;
    const apiConfig = {
      apiKey: config.figmaApiKey,
      cacheConfig: {
        ttl: parseInt(process.env.CACHE_TTL || "300"),
        maxSize: parseInt(process.env.CACHE_MAX_SIZE || "1000")
      },
      rateLimitConfig: {
        requestsPerMinute: parseInt(process.env.RATE_LIMIT_REQUESTS_PER_MINUTE || "60"),
        burstSize: parseInt(process.env.RATE_LIMIT_BURST_SIZE || "10")
      }
    };
    this.figmaApi = new FigmaApiService(apiConfig);
    this.contextProcessor = new ContextProcessor(config.customRules);
    this.server = new Server(
      {
        name: "figma-mcp-pro",
        version: VERSION
      },
      {
        capabilities: {
          tools: {}
        }
      }
    );
    this.setupToolHandlers();
    this.setupErrorHandling();
  }
  // Helper methods to reduce duplication
  parseFigmaUrl(url) {
    try {
      const urlObj = new URL(url);
      const pathParts = urlObj.pathname.split("/");
      const designIndex = pathParts.findIndex((part) => part === "design" || part === "file");
      if (designIndex === -1 || designIndex >= pathParts.length - 1) {
        throw new Error("Invalid Figma URL: could not extract file key");
      }
      const extractedFileKey = pathParts[designIndex + 1];
      if (!extractedFileKey) {
        throw new Error("Invalid Figma URL: file key not found after design path");
      }
      const nodeIdParam = urlObj.searchParams.get("node-id");
      return {
        fileKey: extractedFileKey,
        nodeId: nodeIdParam || void 0
      };
    } catch (error) {
      throw new McpError(
        ErrorCode.InvalidParams,
        `Invalid Figma URL: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  generateWorkflowStatus(stepComplete, nextStep) {
    return {
      [`${stepComplete}_COMPLETE`]: `${stepComplete} completed successfully`,
      ...nextStep && { NEXT_STEP: nextStep },
      COMPLETE_WORKFLOW: _CustomFigmaMcpServer.WORKFLOW_SEQUENCE
    };
  }
  log(...args) {
    if (this.config.debug) {
      console.error(chalk.blue(...args));
    }
  }
  logError(...args) {
    console.error(chalk.red(...args));
  }
  setupToolHandlers() {
    this.server.setRequestHandler(ListToolsRequestSchema, async () => {
      return {
        tools: [
          {
            name: "show_frameworks",
            description: "STEP 1: Show available frameworks to user. Call with empty object {}. Shows options, then STOP and wait for user to tell you their choice. DO NOT make further tool calls until user provides their framework preference.",
            inputSchema: {
              type: "object",
              properties: {},
              required: [],
              additionalProperties: false
            }
          },
          {
            name: "get_figma_data",
            description: "STEP 2: Get well-structured, AI-optimized Figma design data with framework-specific optimizations. Analyzes layout, components, coordinates, visual effects (shadows, borders), design tokens. PURE DESIGN DATA ONLY - no comments. Use AFTER user chooses framework. Can accept full Figma URL to automatically extract file and node selection. If getting unintended content, select a more specific element in Figma.",
            inputSchema: {
              type: "object",
              properties: {
                fileKey: {
                  type: "string",
                  description: "The Figma file key (optional if url provided)"
                },
                url: {
                  type: "string",
                  description: "Full Figma URL with file and node selection (alternative to fileKey + nodeId)"
                },
                nodeId: {
                  type: "string",
                  description: "Specific node ID to fetch (optional, extracted from url if provided)"
                },
                depth: {
                  type: "number",
                  minimum: 1,
                  maximum: 10,
                  default: 5,
                  description: "Maximum depth to traverse"
                },
                framework: {
                  type: "string",
                  enum: ["react", "vue", "angular", "svelte", "html", "swiftui", "uikit", "electron", "tauri", "nwjs"],
                  default: "html",
                  description: "Target framework for optimized CSS and component generation (default: html)"
                },
                includeImages: {
                  type: "boolean",
                  default: false,
                  description: "Whether to include image URLs"
                },
                selectionOnly: {
                  type: "boolean",
                  default: false,
                  description: "DEPRECATED: This parameter is no longer needed. The API correctly fetches only the selected node and its contents. If you are getting unintended content, select a more specific element in Figma (the exact frame/component, not a parent container)."
                },
                customRules: {
                  type: "object",
                  description: "Custom processing rules"
                }
              },
              required: []
            }
          },
          {
            name: "process_design_comments",
            description: "STEP 3: Process designer comments with smart coordinate matching. Use AFTER get_figma_data when you want to analyze designer instructions. Converts comments into actionable AI prompts for implementation.",
            inputSchema: {
              type: "object",
              properties: {
                url: {
                  type: "string",
                  description: "Figma URL to scan for comments (full URL from browser)"
                },
                framework: {
                  type: "string",
                  enum: ["react", "vue", "angular", "svelte", "html", "swiftui", "uikit", "electron", "tauri", "nwjs"],
                  description: "Target framework for code suggestions"
                }
              },
              required: ["url", "framework"]
            }
          },
          {
            name: "download_design_assets",
            description: "STEP 4: Automatically scan selected area for ALL export-ready assets and download them with reference.png. Takes Figma URL, finds all nodes with export settings in selected area, downloads them with Figma export settings, plus creates reference.png of whole selection.",
            inputSchema: {
              type: "object",
              properties: {
                fileKey: {
                  type: "string",
                  description: "The Figma file key (optional if url provided)"
                },
                url: {
                  type: "string",
                  description: "Full Figma URL with file and node selection - will scan selected area for ALL export assets"
                },
                nodeId: {
                  type: "string",
                  description: "Specific node ID to scan for export assets (optional, extracted from url if provided)"
                },
                localPath: {
                  type: "string",
                  description: "Local directory path to save images (will be created if it does not exist). Images will be saved with filenames based on the actual node names from Figma."
                },
                scale: {
                  type: "number",
                  minimum: 0.5,
                  maximum: 4,
                  default: 2,
                  description: "Fallback export scale for images if no export settings found"
                },
                format: {
                  type: "string",
                  enum: ["jpg", "png", "svg", "pdf"],
                  default: "svg",
                  description: "Fallback image format if no export settings found"
                }
              },
              required: ["localPath"]
            }
          },
          {
            name: "check_reference",
            description: "STEP 5: Analyze reference.png file for design understanding. Provides design context, layout analysis, component structure guidance, and framework-specific development recommendations before starting code implementation.",
            inputSchema: {
              type: "object",
              properties: {
                assetsPath: {
                  type: "string",
                  description: "Path to assets folder containing reference.png file"
                },
                framework: {
                  type: "string",
                  enum: ["react", "vue", "angular", "svelte", "html", "swiftui", "uikit", "electron", "tauri", "nwjs"],
                  description: "Target framework for development context (optional)"
                }
              },
              required: ["assetsPath"]
            }
          }
        ]
      };
    });
    this.server.setRequestHandler(CallToolRequestSchema, async (request) => {
      const { name, arguments: args } = request.params;
      try {
        switch (name) {
          case "show_frameworks":
            return await this.handleShowFrameworks(args);
          case "get_figma_data":
            return await this.handleGetFigmaData(args);
          case "process_design_comments":
            return await this.handleProcessDesignComments(args);
          case "download_design_assets":
            return await this.handleDownloadDesignAssets(args);
          case "check_reference":
            return await this.handleCheckReference(args);
          default:
            throw new McpError(
              ErrorCode.MethodNotFound,
              `Unknown tool: ${name}`
            );
        }
      } catch (error) {
        if (error instanceof McpError) {
          throw error;
        }
        this.logError(`Error in tool ${name}:`, error);
        throw new McpError(
          ErrorCode.InternalError,
          `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    });
  }
  async handleShowFrameworks(args) {
    this.log(`[Figma MCP] Showing available frameworks, received args:`, JSON.stringify(args));
    this.log(`[Figma MCP] Args type:`, typeof args);
    try {
      ShowFrameworksSchema.parse(args || {});
    } catch (error) {
      this.logError(`[Figma MCP] Schema validation error for args:`, args);
      this.logError(`[Figma MCP] Schema validation error:`, error);
      throw new McpError(
        ErrorCode.InvalidParams,
        `Invalid parameters: ${error instanceof Error ? error.message : String(error)}`
      );
    }
    const frameworks2 = [
      { id: 1, name: "React", desc: "Modern web framework with TypeScript and hooks" },
      { id: 2, name: "Vue", desc: "Progressive framework with Composition API" },
      { id: 3, name: "Angular", desc: "Full-featured framework with TypeScript" },
      { id: 4, name: "Svelte", desc: "Compile-time framework with reactive updates" },
      { id: 5, name: "HTML/CSS/JS", desc: "Vanilla web technologies, no framework" },
      { id: 6, name: "SwiftUI", desc: "Apple's declarative UI for iOS/macOS apps" },
      { id: 7, name: "UIKit", desc: "Traditional Apple framework for iOS development" },
      { id: 8, name: "Electron", desc: "Cross-platform desktop apps with web tech" },
      { id: 9, name: "Tauri", desc: "Lightweight desktop apps with Rust backend" },
      { id: 10, name: "NW.js", desc: "Desktop apps with Node.js and Chromium" }
    ];
    const frameworkText = `Choose your framework:

${frameworks2.map((f) => `${f.id}. ${f.name} - ${f.desc}`).join("\n")}

Type your choice (1-10):`;
    return {
      content: [
        {
          type: "text",
          text: frameworkText
        },
        {
          type: "text",
          text: `

\u{1F6A8} **CRITICAL AI INSTRUCTION**: 
- Stop here - DO NOT make any more tool calls
- Show framework options to user, short and clearly formatted, and wait for user to respond with framework number (1-10)
- Do NOT proceed to get_figma_data until user chooses
- STEP 1 COMPLETE - User must select framework first`
        }
      ]
    };
  }
  async handleGetFigmaData(args) {
    this.log(`[Figma MCP] Received args:`, JSON.stringify(args, null, 2));
    let parsed;
    try {
      parsed = GetFigmaDataSchema.parse(args);
    } catch (error) {
      this.logError(`[Figma MCP] Schema validation error:`, error);
      throw new McpError(
        ErrorCode.InvalidParams,
        `Invalid parameters: ${error instanceof Error ? error.message : String(error)}`
      );
    }
    const { framework, customRules, selectionOnly } = parsed;
    const depth = parsed.depth || 5;
    let fileKey;
    let nodeId;
    if (parsed.url) {
      this.log(`[Figma MCP] Parsing URL: ${parsed.url}`);
      const urlData = this.parseFigmaUrl(parsed.url);
      fileKey = urlData.fileKey;
      nodeId = urlData.nodeId;
      this.log(`[Figma MCP] Extracted from URL - fileKey: ${fileKey}, nodeId: ${nodeId}`);
    } else {
      if (!parsed.fileKey) {
        throw new McpError(
          ErrorCode.InvalidParams,
          "fileKey is required when url is not provided"
        );
      }
      fileKey = parsed.fileKey;
      nodeId = parsed.nodeId;
      this.log(`[Figma MCP] Using direct parameters - fileKey: ${fileKey}, nodeId: ${nodeId}`);
    }
    const apiNodeId = nodeId ? nodeId.replace(/-/g, ":") : void 0;
    const frameworkRules = getFrameworkRules(framework);
    this.log(`[Figma MCP] Using ${framework} framework with rules:`, frameworkRules);
    this.log(`[Figma MCP] Fetching data for file: ${fileKey} (depth: ${depth})`);
    if (apiNodeId) {
      this.log(`[Figma MCP] Target node: ${apiNodeId} (converted from: ${parsed.nodeId})`);
      this.log(`[Figma MCP] \u{1F4D6} HOW FIGMA SELECTION WORKS:`);
      this.log(`[Figma MCP]    \u2705 When you select a node in Figma, you get that node + ALL its contents`);
      this.log(`[Figma MCP]    \u2705 This is correct - if you select a frame, you get the frame + all components inside`);
      this.log(`[Figma MCP]    \u274C If you're getting OTHER screens you didn't select, you selected a parent container`);
      this.log(`[Figma MCP]    \u{1F4A1} Solution: In Figma, select the SPECIFIC frame/component, not the page or parent`);
    }
    try {
      const mergedRules = customRules ? { ...frameworkRules, ...customRules } : frameworkRules;
      this.contextProcessor.updateRules(mergedRules);
      let figmaData;
      let isSpecificNode = false;
      if (apiNodeId) {
        this.log(`[Figma MCP] Fetching specific node: ${apiNodeId}`);
        this.log(`[Figma MCP] Using depth ${depth} to get complete content of selected node`);
        if (selectionOnly) {
          this.log(`[Figma MCP] Selection-only mode: Will filter out sibling content during processing`);
        }
        try {
          const nodeResponse = await this.figmaApi.getFileNodes(fileKey, [apiNodeId], {
            depth,
            use_absolute_bounds: true
          });
          this.log(`[Figma MCP] Node response received, keys:`, Object.keys(nodeResponse.nodes));
          const nodeWrapper = nodeResponse.nodes[apiNodeId];
          if (!nodeWrapper) {
            throw new Error(`Node ${apiNodeId} not found in file ${fileKey}. Available nodes: ${Object.keys(nodeResponse.nodes).join(", ")}`);
          }
          figmaData = nodeWrapper.document;
          isSpecificNode = true;
        } catch (apiError) {
          this.logError(`[Figma MCP] API error fetching node ${apiNodeId}:`, apiError);
          throw apiError;
        }
      } else {
        this.log(`[Figma MCP] Fetching entire document (no specific selection)`);
        try {
          const fileResponse = await this.figmaApi.getFile(fileKey, {
            depth,
            use_absolute_bounds: true
          });
          this.log(`[Figma MCP] File response received for document:`, fileResponse.document?.name);
          figmaData = fileResponse.document;
        } catch (apiError) {
          this.logError(`[Figma MCP] API error fetching file ${fileKey}:`, apiError);
          throw apiError;
        }
      }
      this.log(`[Figma MCP] Raw data structure (${isSpecificNode ? "SPECIFIC SELECTION" : "FULL DOCUMENT"}):`);
      this.log(`- Node ID: ${figmaData.id}`);
      this.log(`- Node Name: ${figmaData.name}`);
      this.log(`- Node Type: ${figmaData.type}`);
      this.log(`- Has Children: ${figmaData.children ? figmaData.children.length : 0}`);
      if (figmaData.children && figmaData.children.length > 0) {
        const maxChildren = isSpecificNode ? Math.min(10, figmaData.children.length) : Math.min(5, figmaData.children.length);
        this.log(`[Figma MCP] Showing ${maxChildren} of ${figmaData.children.length} children:`);
        for (let i = 0; i < maxChildren; i++) {
          const child = figmaData.children[i];
          if (child) {
            this.log(`  - Child ${i}: "${child.name}" (${child.type}) - Children: ${child.children ? child.children.length : 0}`);
            if (child.absoluteBoundingBox) {
              this.log(`    Bounds: ${Math.round(child.absoluteBoundingBox.x)}, ${Math.round(child.absoluteBoundingBox.y)} (${Math.round(child.absoluteBoundingBox.width)}x${Math.round(child.absoluteBoundingBox.height)})`);
            }
          }
        }
        if (figmaData.children.length > maxChildren) {
          this.log(`  - ... and ${figmaData.children.length - maxChildren} more children`);
        }
      }
      if (isSpecificNode && figmaData.children && figmaData.children.length > 1) {
        this.log(`[Figma MCP] \u2705 SELECTION ANALYSIS: You selected "${figmaData.name}" (${figmaData.type}) which contains ${figmaData.children.length} child elements.`);
        this.log(`[Figma MCP] \u{1F4CB} This is the correct behavior - you get the selected element AND all its contents.`);
        this.log(`[Figma MCP] \u{1F4A1} If you're seeing content from OTHER screens you didn't select:`);
        this.log(`[Figma MCP]    - You may have selected a parent container (like a page or large frame)`);
        this.log(`[Figma MCP]    - In Figma, select the SPECIFIC frame/component you want, not its parent`);
        this.log(`[Figma MCP]    - Look for the exact screen/component in the layers panel and select that`);
      } else if (isSpecificNode) {
        this.log(`[Figma MCP] \u2705 SELECTION ANALYSIS: You selected "${figmaData.name}" (${figmaData.type}) - single element with no children.`);
      }
      const processingContext = {
        fileKey,
        depth: 0,
        siblingIndex: 0,
        totalSiblings: 1,
        framework
      };
      let enhancedData = await this.contextProcessor.processNode(figmaData, processingContext);
      const stats = this.contextProcessor.getStats();
      this.log(`[Figma MCP] Successfully processed ${stats.nodesProcessed} nodes`);
      const optimizedData = this.contextProcessor.optimizeForAI(enhancedData);
      const debugInfo = {
        framework,
        frameworkRules,
        source: isSpecificNode ? "selection" : "document",
        processed: stats.nodesProcessed,
        selectedNode: isSpecificNode ? { id: figmaData.id, name: figmaData.name, type: figmaData.type, childCount: figmaData.children?.length || 0 } : null,
        IMPORTANT_NEXT_STEPS: {
          STEP_3: "REQUIRED: Use process_design_comments tool to check for designer comments",
          STEP_4: "Use download_design_assets tool to get images and visual reference",
          STEP_5: "Use check_reference tool to analyze reference.png before development",
          COMPLETE_WORKFLOW: _CustomFigmaMcpServer.WORKFLOW_SEQUENCE,
          CURRENT_STATUS: "STEP 2 COMPLETE - Design data extracted successfully"
        }
      };
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              // Essential metadata FIRST - so AI sees guidance immediately
              metadata: debugInfo,
              // Primary data: AI-optimized and clean  
              data: optimizedData
            }, null, 2)
          }
        ]
      };
    } catch (error) {
      this.logError(`[Figma MCP] Error fetching data:`, error);
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to fetch Figma data: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  async handleProcessDesignComments(args) {
    this.log(`[Figma MCP] Processing design comments:`, JSON.stringify(args, null, 2));
    let parsed;
    try {
      parsed = ProcessDesignCommentsSchema.parse(args);
    } catch (error) {
      this.logError(`[Figma MCP] Schema validation error:`, error);
      throw new McpError(
        ErrorCode.InvalidParams,
        `Invalid parameters: ${error instanceof Error ? error.message : String(error)}`
      );
    }
    const { url, framework } = parsed;
    const urlData = this.parseFigmaUrl(url);
    const fileKey = urlData.fileKey;
    const nodeId = urlData.nodeId;
    this.log(`[Figma MCP] Parsed URL - fileKey: ${fileKey}, nodeId: ${nodeId}, framework: ${framework}`);
    try {
      this.log(`[Figma MCP] Fetching comments for file: ${fileKey}`);
      const commentsResponse = await this.figmaApi.getComments(fileKey);
      let relevantComments = commentsResponse.comments;
      if (nodeId) {
        const apiNodeId = nodeId.replace(/-/g, ":");
        this.log(`[Figma MCP] Filtering comments for specific node: ${apiNodeId} (from ${nodeId})`);
        let selectedNodeBounds = null;
        try {
          const nodeResponse = await this.figmaApi.getFileNodes(fileKey, [apiNodeId], { depth: 1 });
          const selectedNode = nodeResponse.nodes[apiNodeId]?.document;
          if (selectedNode?.absoluteBoundingBox) {
            selectedNodeBounds = selectedNode.absoluteBoundingBox;
            this.log(`[Figma MCP] Selected node bounds:`, selectedNodeBounds);
          }
        } catch (boundsError) {
          this.log(`[Figma MCP] Could not get node bounds for filtering:`, boundsError);
        }
        const originalCount = relevantComments.length;
        relevantComments = relevantComments.filter((comment) => {
          if (comment.client_meta?.node_id === apiNodeId) {
            this.log(`[Figma MCP] Comment directly on selected node: "${comment.message}"`);
            return true;
          }
          if (selectedNodeBounds) {
            const commentAny = comment;
            const commentX = comment.client_meta?.node_offset?.x || comment.client_meta?.x || commentAny.x;
            const commentY = comment.client_meta?.node_offset?.y || comment.client_meta?.y || commentAny.y;
            if (commentX !== void 0 && commentY !== void 0) {
              const isWithinBounds = commentX >= selectedNodeBounds.x && commentX <= selectedNodeBounds.x + selectedNodeBounds.width && commentY >= selectedNodeBounds.y && commentY <= selectedNodeBounds.y + selectedNodeBounds.height;
              if (isWithinBounds) {
                this.log(`[Figma MCP] Comment within node bounds: "${comment.message}" at (${commentX}, ${commentY})`);
                return true;
              }
            }
          }
          return false;
        });
        this.log(`[Figma MCP] Comment filtering: ${originalCount} total \u2192 ${relevantComments.length} relevant to selected node`);
      }
      this.log(`[Figma MCP] Found ${relevantComments.length} comments to process${nodeId ? " for selected node" : " in file"}`);
      if (relevantComments.length === 0) {
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                message: nodeId ? "No comments found for the selected node/section" : "No comments found in this design",
                comments: [],
                aiPrompts: [],
                nodeSelection: nodeId ? `Checked for comments on node: ${nodeId}` : "Checked entire file",
                WORKFLOW_STATUS: this.generateWorkflowStatus("STEP_3", "STEP 4: Use download_design_assets tool to get images and reference.png")
              }, null, 2)
            }
          ]
        };
      }
      this.log(`[Figma MCP] Fetching design data for element analysis`);
      const figmaDataArgs = {
        fileKey,
        framework,
        includeComments: false,
        depth: 5
      };
      if (nodeId) {
        figmaDataArgs.nodeId = nodeId;
      }
      const figmaDataResult = await this.handleGetFigmaData(figmaDataArgs);
      const analysisData = figmaDataResult?.content?.[0]?.text ? JSON.parse(figmaDataResult.content[0].text) : {};
      const elementsWithBounds = this.extractElementsWithBounds(analysisData.data);
      this.log(`[Figma MCP] Extracted ${elementsWithBounds.length} elements with bounds for matching`);
      const implementations = [];
      this.log(`[Figma MCP] Debug - Relevant comments structure:`, JSON.stringify(relevantComments, null, 2));
      this.log(`[Figma MCP] Debug - Elements with bounds:`, elementsWithBounds.length);
      for (const comment of relevantComments) {
        this.log(`[Figma MCP] Debug - Processing comment:`, JSON.stringify(comment, null, 2));
        let coordinates = null;
        if (comment.client_meta?.node_offset) {
          coordinates = {
            x: comment.client_meta.node_offset.x,
            y: comment.client_meta.node_offset.y
          };
          this.log(`[Figma MCP] Found coordinates: (${coordinates.x}, ${coordinates.y})`);
        } else {
          this.log(`[Figma MCP] No coordinates in client_meta.node_offset`);
          this.log(`[Figma MCP] Available client_meta:`, comment.client_meta || "null");
        }
        let targetElement = null;
        if (coordinates) {
          const candidateElements = elementsWithBounds.filter((element) => {
            const bounds = element.bounds;
            const isInside = coordinates.x >= bounds.x && coordinates.x <= bounds.x + bounds.width && coordinates.y >= bounds.y && coordinates.y <= bounds.y + bounds.height;
            if (!isInside) {
              const centerX = bounds.x + bounds.width / 2;
              const centerY = bounds.y + bounds.height / 2;
              const distance = Math.sqrt(Math.pow(coordinates.x - centerX, 2) + Math.pow(coordinates.y - centerY, 2));
              return distance <= 100;
            }
            return true;
          });
          if (candidateElements.length > 0) {
            candidateElements.sort((a, b) => {
              const distA = Math.sqrt(
                Math.pow(coordinates.x - (a.bounds.x + a.bounds.width / 2), 2) + Math.pow(coordinates.y - (a.bounds.y + a.bounds.height / 2), 2)
              );
              const distB = Math.sqrt(
                Math.pow(coordinates.x - (b.bounds.x + b.bounds.width / 2), 2) + Math.pow(coordinates.y - (b.bounds.y + b.bounds.height / 2), 2)
              );
              return distA - distB;
            });
            targetElement = candidateElements[0]?.name;
            this.log(`[Figma MCP] Matched comment to element: ${targetElement}`);
          }
        }
        const implementation = {
          instruction: comment.message,
          targetElement: targetElement || "Apply to relevant design element",
          coordinates
        };
        implementations.push(implementation);
        this.log(`[Figma MCP] Added implementation: "${comment.message}" \u2192 ${targetElement || "General"}`);
      }
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              implementations,
              framework,
              nodeContext: nodeId ? `Comments for node: ${nodeId}` : "Comments for entire file",
              WORKFLOW_STATUS: this.generateWorkflowStatus("STEP_3", "STEP 4: Use download_design_assets tool to get images and reference.png")
            }, null, 2)
          }
        ]
      };
    } catch (error) {
      this.logError(`[Figma MCP] Error processing comments:`, error);
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to process design comments: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  /**
   * Extract all elements with bounds from analysis data recursively
   */
  extractElementsWithBounds(data) {
    const elements = [];
    const traverse = (node, path3 = "") => {
      const fullPath = path3 ? `${path3} > ${node.name}` : node.name;
      let bounds = null;
      if (node.bounds) {
        bounds = node.bounds;
      } else if (node.absoluteBoundingBox) {
        bounds = {
          x: node.absoluteBoundingBox.x,
          y: node.absoluteBoundingBox.y,
          width: node.absoluteBoundingBox.width,
          height: node.absoluteBoundingBox.height
        };
      } else if (node.relativeTransform && node.size) {
        bounds = {
          x: node.relativeTransform[0][2] || 0,
          y: node.relativeTransform[1][2] || 0,
          width: node.size.x || 0,
          height: node.size.y || 0
        };
      }
      if (bounds && node.id && node.name && node.type) {
        elements.push({
          id: node.id,
          name: node.name,
          type: node.type,
          bounds,
          path: fullPath
        });
        this.log(`[DEBUG] Added element: ${node.name} (${node.type}) at (${bounds.x}, ${bounds.y}) size ${bounds.width}x${bounds.height}`);
      } else {
        this.log(`[DEBUG] Skipped element: ${node.name || "unnamed"} - missing bounds or required fields`);
        this.log(`[DEBUG] Available node fields:`, Object.keys(node));
      }
      if (node.children && Array.isArray(node.children)) {
        for (const child of node.children) {
          traverse(child, fullPath);
        }
      }
    };
    traverse(data);
    return elements;
  }
  /**
   * Setup project assets directory and copy from Cursor fallback location
   * This handles the Cursor IDE working directory bug by copying assets from the fallback location
   */
  async handleCheckReference(args) {
    this.log(`[Figma MCP] Checking reference image:`, JSON.stringify(args, null, 2));
    let parsed;
    try {
      parsed = CheckReferenceSchema.parse(args);
    } catch (error) {
      this.logError(`[Figma MCP] Schema validation error:`, error);
      throw new McpError(
        ErrorCode.InvalidParams,
        `Invalid parameters: ${error instanceof Error ? error.message : String(error)}`
      );
    }
    const { assetsPath, framework: _framework } = parsed;
    try {
      const resolvedPath = path2.isAbsolute(assetsPath) ? assetsPath : path2.resolve(process.cwd(), assetsPath);
      const referencePath = path2.join(resolvedPath, "reference.png");
      this.log(`[Figma MCP] Looking for reference.png at: ${referencePath}`);
      try {
        const fileStats = await fs2.stat(referencePath);
        if (!fileStats.isFile() || fileStats.size === 0) {
          throw new Error("File exists but is invalid");
        }
        const fileSizeKB = Math.round(fileStats.size / 1024);
        const relativePath = path2.relative(process.cwd(), referencePath);
        this.log(`[Figma MCP] \u2705 Reference found: ${referencePath} (${fileSizeKB}KB)`);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                status: "success",
                message: "reference.png found and verified",
                reference: {
                  path: relativePath,
                  size: `${fileSizeKB} KB`,
                  verified: true
                },
                instruction: "Analyze reference.png with all collected design data to understand layout, components, and visual context before code implementation",
                STEP_5_COMPLETE: true,
                NEXT_ACTION: "Implement code using reference.png analysis + design data + downloaded assets",
                READY_FOR_DEVELOPMENT: true
              }, null, 2)
            }
          ]
        };
      } catch (statError) {
        this.log(`[Figma MCP] \u274C reference.png not found at: ${referencePath}`);
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                status: "error",
                message: "reference.png not found in assets folder",
                expectedPath: referencePath,
                REQUIRED_ACTION: "Run download_design_assets first to create reference.png",
                STEP_4_MISSING: "download_design_assets must be completed before check_reference",
                NEXT_STEP: "Call download_design_assets with your Figma URL to create reference.png"
              }, null, 2)
            }
          ]
        };
      }
    } catch (error) {
      this.logError(`[Figma MCP] Error checking reference:`, error);
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to check reference: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  async handleDownloadDesignAssets(args) {
    const parsed = DownloadFigmaImagesSchema.parse(args);
    const { localPath } = parsed;
    this.log(`[Figma MCP] \u{1F50D} DEBUG: Download request analysis:`);
    this.log(`[Figma MCP] \u{1F4C1} Requested localPath: "${localPath}"`);
    this.log(`[Figma MCP] \u{1F30D} Environment context:`);
    this.log(`[Figma MCP]   - process.cwd(): "${process.cwd()}"`);
    this.log(`[Figma MCP]   - PWD: "${process.env.PWD || "undefined"}"`);
    this.log(`[Figma MCP]   - INIT_CWD: "${process.env.INIT_CWD || "undefined"}"`);
    this.log(`[Figma MCP]   - PROJECT_ROOT: "${process.env.PROJECT_ROOT || "undefined"}"`);
    this.log(`[Figma MCP]   - WORKSPACE_ROOT: "${process.env.WORKSPACE_ROOT || "undefined"}"`);
    let fileKey;
    let nodeId;
    if (parsed.url) {
      this.log(`[Figma MCP] Parsing URL: ${parsed.url}`);
      const urlData = this.parseFigmaUrl(parsed.url);
      fileKey = urlData.fileKey;
      nodeId = urlData.nodeId;
      this.log(`[Figma MCP] Extracted from URL - fileKey: ${fileKey}, nodeId: ${nodeId}`);
    } else {
      if (!parsed.fileKey) {
        throw new McpError(
          ErrorCode.InvalidParams,
          "fileKey is required when url is not provided"
        );
      }
      fileKey = parsed.fileKey;
      nodeId = parsed.nodeId;
      this.log(`[Figma MCP] Using direct parameters - fileKey: ${fileKey}, nodeId: ${nodeId}`);
    }
    const apiNodeId = nodeId ? nodeId.replace(/-/g, ":") : void 0;
    this.log(`[Figma MCP] Scanning for export assets in ${apiNodeId ? `selected area: ${apiNodeId}` : "entire file"}`);
    try {
      let targetNode;
      if (apiNodeId) {
        this.log(`[Figma MCP] Fetching selected node: ${apiNodeId}`);
        const nodeResponse = await this.figmaApi.getFileNodes(fileKey, [apiNodeId], {
          depth: 10,
          // Deep scan to find all export assets
          use_absolute_bounds: true
        });
        const nodeWrapper = nodeResponse.nodes[apiNodeId];
        if (!nodeWrapper) {
          throw new Error(`Node ${apiNodeId} not found in file ${fileKey}`);
        }
        targetNode = nodeWrapper.document;
      } else {
        this.log(`[Figma MCP] Fetching entire document for export scan`);
        const fileResponse = await this.figmaApi.getFile(fileKey, {
          depth: 10,
          // Deep scan to find all export assets
          use_absolute_bounds: true
        });
        targetNode = fileResponse.document;
      }
      const exportableNodes = this.findNodesWithExportSettings(targetNode);
      this.log(`[Figma MCP] Found ${exportableNodes.length} nodes with export settings`);
      if (exportableNodes.length === 0) {
        this.log(`[Figma MCP] No export settings found in selected area`);
        let referenceResult2 = null;
        try {
          this.log(`[Figma MCP] Creating visual reference of selected area...`);
          referenceResult2 = await this.createVisualReference(fileKey, apiNodeId ? [apiNodeId] : [], localPath);
        } catch (referenceError) {
          this.logError(`[Figma MCP] Failed to create reference:`, referenceError);
        }
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                downloads: [],
                summary: { total: 0, successful: 0, failed: 0 },
                reference: referenceResult2,
                message: "No export settings found in selected area. Only reference.png created.",
                instructions: this.generateDownloadInstructions([], referenceResult2)
              }, null, 2)
            }
          ]
        };
      }
      this.log(`[Figma MCP] \u{1F525} DEBUG: About to download ${exportableNodes.length} export-ready assets...`);
      this.log(`[Figma MCP] \u{1F4C1} Target localPath: "${localPath}"`);
      const downloadResult = await this.figmaApi.downloadImagesWithExportSettings(
        fileKey,
        exportableNodes,
        localPath,
        { skipWorkspaceEnforcement: true, overwriteExisting: true }
      );
      this.log(`[Figma MCP] \u{1F525} DEBUG: Export download completed!`);
      this.log(`[Figma MCP] \u{1F4CA} Summary: ${downloadResult.summary.successful} successful, ${downloadResult.summary.failed} failed`);
      this.log(`[Figma MCP] \u{1F4C1} Workspace enforcement result:`, downloadResult.workspaceEnforcement || "No enforcement info");
      if (downloadResult.downloaded.length > 0) {
        this.log(`[Figma MCP] \u{1F50D} DEBUG: Actual download locations:`);
        downloadResult.downloaded.forEach((download, index) => {
          this.log(`[Figma MCP]   ${index + 1}. ${download.nodeName} \u2192 ${download.filePath} (success: ${download.success})`);
        });
      }
      let referenceResult = null;
      try {
        this.log(`[Figma MCP] Creating visual reference of selected area...`);
        referenceResult = await this.createVisualReference(fileKey, apiNodeId ? [apiNodeId] : [], localPath);
        if (referenceResult?.success) {
          this.log(`[Figma MCP] \u2705 Reference created at: ${referenceResult.filePath}`);
        } else {
          this.log(`[Figma MCP] \u26A0\uFE0F Reference creation failed:`, referenceResult?.error);
        }
      } catch (referenceError) {
        this.logError(`[Figma MCP] Failed to create reference:`, referenceError);
      }
      this.log(`[Figma MCP] \u{1F50D} DEBUG: Final verification of file locations:`);
      for (const download of downloadResult.downloaded) {
        if (download.success) {
          try {
            const stat = await fs2.stat(download.filePath);
            const relativePath = path2.relative(process.cwd(), download.filePath);
            this.log(`[Figma MCP] \u2705 Verified: ${download.nodeName}`);
            this.log(`[Figma MCP]     \u{1F4C1} Absolute: ${download.filePath}`);
            this.log(`[Figma MCP]     \u{1F4C2} Relative: ${relativePath}`);
            this.log(`[Figma MCP]     \u{1F4E6} Size: ${Math.round(stat.size / 1024)}KB`);
          } catch (verifyError) {
            this.log(`[Figma MCP] \u274C NOT FOUND: ${download.nodeName} at ${download.filePath}`);
          }
        }
      }
      return {
        content: [
          {
            type: "text",
            text: JSON.stringify({
              downloads: downloadResult.downloaded,
              summary: downloadResult.summary,
              reference: referenceResult,
              workspaceEnforcement: downloadResult.workspaceEnforcement,
              debug: {
                requestedPath: localPath,
                resolvedWorkspace: downloadResult.workspaceEnforcement?.finalLocation || "No workspace info",
                actualPaths: downloadResult.downloaded.map((d) => ({
                  name: d.nodeName,
                  path: d.filePath,
                  success: d.success
                }))
              },
              exportSettings: {
                found: exportableNodes.length,
                downloaded: downloadResult.summary.successful,
                scope: apiNodeId ? `Selected area: ${nodeId}` : "Entire file"
              },
              message: downloadResult.summary.total === 0 ? "No export assets found to download." : `Downloaded ${downloadResult.summary.successful} export-ready assets with Figma export settings, plus reference.png of selected area.`,
              instructions: this.generateDownloadInstructions(downloadResult.downloaded, referenceResult)
            }, null, 2)
          }
        ]
      };
    } catch (error) {
      this.logError(`[Figma MCP] Error downloading assets:`, error);
      throw new McpError(
        ErrorCode.InternalError,
        `Failed to download assets: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  /**
   * Find all nodes with Figma export settings configured
   */
  findNodesWithExportSettings(node) {
    const exportableNodes = [];
    const scanNode = (currentNode) => {
      if (currentNode.exportSettings && Array.isArray(currentNode.exportSettings) && currentNode.exportSettings.length > 0) {
        this.log(`[Figma MCP] Found export settings on node: ${currentNode.name} (${currentNode.type}) - ${currentNode.exportSettings.length} settings`);
        exportableNodes.push(currentNode);
      }
      if (currentNode.children && Array.isArray(currentNode.children)) {
        currentNode.children.forEach((child) => {
          scanNode(child);
        });
      }
    };
    if (node) {
      scanNode(node);
    }
    this.log(`[Figma MCP] Export scan complete: found ${exportableNodes.length} nodes with export settings`);
    return exportableNodes;
  }
  /**
   * Create visual context reference by finding and downloading the parent context
   */
  async createVisualReference(fileKey, selectedNodeIds, localPath) {
    try {
      let referenceNodeId = null;
      let contextType = "document";
      let contextName = "Visual Context";
      if (selectedNodeIds.length === 1 && selectedNodeIds[0]) {
        const firstNodeId = selectedNodeIds[0];
        try {
          const nodeResponse = await this.figmaApi.getFileNodes(fileKey, [firstNodeId], { depth: 2 });
          const selectedNode = nodeResponse.nodes[firstNodeId]?.document;
          if (selectedNode) {
            referenceNodeId = selectedNode.id;
            contextType = selectedNode.type === "CANVAS" ? "page" : "parent-frame";
            contextName = selectedNode.name;
            this.log(`[Figma MCP] Using selected node as reference: ${contextName} (${selectedNode.type})`);
          } else {
            this.log(`[Figma MCP] Selected node not found, trying page fallback`);
          }
        } catch (nodeError) {
          this.log(`[Figma MCP] Could not get selected node details:`, nodeError);
        }
      } else if (selectedNodeIds.length > 1 && selectedNodeIds[0]) {
        referenceNodeId = selectedNodeIds[0];
        contextType = "parent-frame";
        contextName = "Multiple Selection Context";
        this.log(`[Figma MCP] Multiple selections, using first node as reference context`);
      }
      if (!referenceNodeId) {
        this.log(`[Figma MCP] No specific selection context, falling back to page`);
        try {
          const fileResponse = await this.figmaApi.getFile(fileKey, { depth: 2 });
          if (fileResponse.document?.children?.[0]) {
            referenceNodeId = fileResponse.document.children[0].id;
            contextType = "page";
            contextName = fileResponse.document.children[0].name;
          }
        } catch (fileError) {
          return {
            success: false,
            contextType: "document",
            error: "Could not access file for reference context"
          };
        }
      }
      if (!referenceNodeId) {
        return {
          success: false,
          contextType: "document",
          error: "Could not determine reference context"
        };
      }
      this.log(`[Figma MCP] Creating reference from ${contextType}: "${contextName}" (${referenceNodeId})`);
      const referenceDownload = await this.figmaApi.downloadImages(
        fileKey,
        [referenceNodeId],
        localPath,
        {
          scale: 1,
          // Use 1x scale as requested by user
          format: "png",
          skipWorkspaceEnforcement: true
        }
      );
      if (referenceDownload.summary.successful === 0) {
        return {
          success: false,
          contextType,
          contextName,
          error: "Failed to download reference image"
        };
      }
      const originalFile = referenceDownload.downloaded[0];
      if (originalFile && originalFile.success) {
        const referenceFilePath = path2.join(localPath, "reference.png");
        this.log(`[Figma MCP] \u{1F504} Converting "${path2.basename(originalFile.filePath)}" \u2192 "reference.png"`);
        try {
          await fs2.access(originalFile.filePath);
          await fs2.rename(originalFile.filePath, referenceFilePath);
          this.log(`[Figma MCP] \u2705 Successfully renamed to reference.png via fs.rename`);
          return {
            success: true,
            filePath: referenceFilePath,
            contextType,
            contextName
          };
        } catch (renameError) {
          this.log(`[Figma MCP] \u26A0\uFE0F Direct rename failed (${renameError}), trying copy + delete...`);
          try {
            await fs2.access(originalFile.filePath);
            await fs2.copyFile(originalFile.filePath, referenceFilePath);
            const copyStats = await fs2.stat(referenceFilePath);
            if (copyStats.size > 0) {
              try {
                await fs2.unlink(originalFile.filePath);
                this.log(`[Figma MCP] \u2705 Successfully created reference.png via copy + delete`);
              } catch (deleteError) {
                this.log(`[Figma MCP] \u26A0\uFE0F Copy succeeded but original file deletion failed: ${deleteError}`);
              }
              return {
                success: true,
                filePath: referenceFilePath,
                contextType,
                contextName
              };
            } else {
              throw new Error("Copy resulted in empty file");
            }
          } catch (copyError) {
            this.logError(`[Figma MCP] \u274C Both rename and copy failed:`, copyError);
            try {
              await fs2.access(originalFile.filePath);
              await fs2.link(originalFile.filePath, referenceFilePath);
              this.log(`[Figma MCP] \u2705 Successfully created reference.png via hard link`);
              return {
                success: true,
                filePath: referenceFilePath,
                contextType,
                contextName
              };
            } catch (linkError) {
              this.logError(`[Figma MCP] \u274C Hard link creation failed:`, linkError);
              this.log(`[Figma MCP] \u{1F527} Using original file as reference: ${path2.basename(originalFile.filePath)}`);
              return {
                success: true,
                filePath: originalFile.filePath,
                // Use original path
                contextType,
                contextName,
                error: `Warning: Could not rename to reference.png, using original filename: ${path2.basename(originalFile.filePath)}`
              };
            }
          }
        }
      }
      return {
        success: false,
        contextType,
        contextName,
        error: "Reference download was not successful"
      };
    } catch (error) {
      this.logError(`[Figma MCP] Error creating visual reference:`, error);
      return {
        success: false,
        contextType: "document",
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }
  /**
   * Generate instructions for using downloaded assets and reference (Universal IDE compatibility)
   */
  generateDownloadInstructions(downloads, referenceResult) {
    const instructions = [];
    const workingDir = process.cwd();
    if (downloads.length > 0) {
      instructions.push(`\u{1F4C1} Asset Files Downloaded:`);
      downloads.forEach((download) => {
        if (download.success) {
          const filename = download.filePath.split("/").pop() || "unknown";
          const relativePath = download.relativePath || `./${filename}`;
          const fileSize = download.fileSize ? ` (${Math.round(download.fileSize / 1024)}KB)` : "";
          const verified = download.verified !== false ? "\u2705" : "\u26A0\uFE0F";
          instructions.push(`   ${verified} ${download.nodeName}`);
          instructions.push(`      \u{1F4C1} File: ${filename}${fileSize}`);
          instructions.push(`      \u{1F4C2} Path: ${relativePath}`);
          if (download.verified === false) {
            instructions.push(`      \u26A0\uFE0F  File verification failed - check directory structure`);
          }
        } else {
          instructions.push(`   \u274C ${download.nodeId || download.nodeName} \u2192 Failed: ${download.error}`);
        }
      });
      instructions.push("");
    }
    if (referenceResult?.success) {
      const referenceRelativePath = referenceResult.filePath ? path2.relative(workingDir, referenceResult.filePath) : "./reference.png";
      instructions.push(`\u{1F3AF} Visual Context Reference:`);
      instructions.push(`   \u{1F4C4} reference.png \u2192 Shows ${referenceResult.contextType} context: "${referenceResult.contextName}"`);
      instructions.push(`   \u{1F4C2} Path: ${referenceRelativePath.startsWith(".") ? referenceRelativePath : `./${referenceRelativePath}`}`);
      instructions.push(`   \u{1F4A1} Use this reference to understand how downloaded assets fit in the overall design`);
      instructions.push(`   \u{1F50D} Open reference.png to see layout, positioning, and relationship between elements`);
      instructions.push("");
    }
    instructions.push(`\u{1F504} NEXT STEP - CRITICAL FOR AI WORKFLOW:`);
    instructions.push(`   \u26A1 Use check_reference tool to analyze reference.png before development`);
    instructions.push(`   \u{1F4C2} Pass the assets folder path to check_reference tool`);
    instructions.push(`   \u{1F3AF} This provides design understanding and framework-specific guidance`);
    instructions.push(`   \u2705 STEP 4 COMPLETE - Assets downloaded, proceed to STEP 5: check_reference`);
    instructions.push(``);
    instructions.push(`\u{1F6E0}\uFE0F Universal IDE Development Workflow:`);
    instructions.push(`   1. Assets are saved using relative paths (./assets/...) for cross-IDE compatibility`);
    instructions.push(`   2. reference.png shows the complete design context and layout`);
    instructions.push(`   3. Use individual asset files for implementation`);
    instructions.push(`   4. All paths are verified after download to ensure availability`);
    instructions.push(`   5. Files work consistently across Cursor, Windsurf, TRAE, and other IDEs`);
    return instructions;
  }
  setupErrorHandling() {
    this.server.onerror = (error) => {
      this.logError("[Figma MCP] Server error:", error);
    };
    process.on("SIGINT", async () => {
      this.logError("\n[Figma MCP] Shutting down server...");
      await this.server.close();
      process.exit(0);
    });
  }
  async start() {
    const transport = new StdioServerTransport();
    await this.server.connect(transport);
    this.log("[Figma MCP] Debug mode enabled");
    this.logError("[Figma MCP] Server started successfully");
  }
};
var program = new Command();
program.name("figma-mcp-pro").description("Professional Figma MCP Server with enhanced AI context processing").version(VERSION).requiredOption("--figma-api-key <key>", "Figma API key", process.env.FIGMA_API_KEY).option("--port <port>", "Server port", process.env.PORT).option("--debug", "Enable debug mode", process.env.DEBUG === "true").option("--stdio", "Use stdio transport (default)", true).action(async (options) => {
  if (!options.figmaApiKey) {
    console.error("Error: Figma API key is required");
    console.error("Set FIGMA_API_KEY environment variable or use --figma-api-key option");
    process.exit(1);
  }
  try {
    const server = new CustomFigmaMcpServer({
      figmaApiKey: options.figmaApiKey,
      port: options.port ? parseInt(options.port) : void 0,
      debug: options.debug
    });
    await server.start();
  } catch (error) {
    console.error("Failed to start server:", error);
    process.exit(1);
  }
});
process.on("unhandledRejection", (reason, promise) => {
  console.error("Unhandled Rejection at:", promise, "reason:", reason);
  process.exit(1);
});
process.on("uncaughtException", (error) => {
  console.error("Uncaught Exception:", error);
  process.exit(1);
});
program.parse();
//# sourceMappingURL=index.js.map